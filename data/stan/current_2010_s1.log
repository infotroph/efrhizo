Starting current_2010_s1 on  Thu Jan 12 21:48:22 UTC 2017
Running mctd_foursurf.R for year  2010  session  1
Loading required package: ggplot2
Loading required package: StanHeaders
rstan (Version 2.14.1, packaged: 2016-12-28 14:55:41 UTC, GitRev: 5fa1e80eb817)
For execution on a local, multicore CPU with excess RAM we recommend calling
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
R version 3.3.2 (2016-10-31)
Platform: x86_64-apple-darwin13.4.0 (64-bit)
Running under: OS X El Capitan 10.11.6

locale:
[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8

attached base packages:
[1] stats     graphics  grDevices utils     datasets  base     

other attached packages:
[1] rstan_2.14.1       StanHeaders_2.14.0 ggplot2_2.2.1     

loaded via a namespace (and not attached):
 [1] colorspace_1.3-2 scales_0.4.1     assertthat_0.1   lazyeval_0.2.0  
 [5] plyr_1.8.4       tools_3.3.2      inline_0.3.14    gtable_0.2.0    
 [9] tibble_1.2       gridExtra_2.2.1  Rcpp_0.12.8      grid_3.3.2      
[13] methods_3.3.2    stats4_3.3.2     munsell_0.4.3   
structure(list(Tube = c(9L, 10L, 11L, 12L, 13L, 14L, 15L, 16L, 
17L, 18L, 19L, 20L, 33L, 34L, 35L, 36L, 37L, 38L, 39L, 40L, 41L, 
42L, 43L, 44L, 45L, 46L, 47L, 48L, 49L, 51L, 52L, 53L, 54L, 55L, 
56L, 57L, 58L, 59L, 60L, 62L, 63L, 64L, 65L, 66L, 67L, 69L, 70L, 
71L, 72L, 73L, 74L, 75L, 76L, 77L, 78L, 79L, 80L, 81L, 82L, 83L, 
84L, 85L, 86L, 87L, 88L, 89L, 90L, 91L, 92L, 93L, 94L, 95L, 96L
), Tube_alias = 1:73), .Names = c("Tube", "Tube_alias"), row.names = c(NA, 
-73L), class = "data.frame")
   Tube Tube_alias
1     9          1
2    10          2
3    11          3
4    12          4
5    13          5
6    14          6
7    15          7
8    16          8
9    17          9
10   18         10
11   19         11
12   20         12
13   33         13
14   34         14
15   35         15
16   36         16
17   37         17
18   38         18
19   39         19
20   40         20
21   41         21
22   42         22
23   43         23
24   44         24
25   45         25
26   46         26
27   47         27
28   48         28
29   49         29
30   51         30
31   52         31
32   53         32
33   54         33
34   55         34
35   56         35
36   57         36
37   58         37
38   59         38
39   60         39
40   62         40
41   63         41
42   64         42
43   65         43
44   66         44
45   67         45
46   69         46
47   70         47
48   71         48
49   72         49
50   73         50
51   74         51
52   75         52
53   76         53
54   77         54
55   78         55
56   79         56
57   80         57
58   81         58
59   82         59
60   83         60
61   84         61
62   85         62
63   86         63
64   87         64
65   88         65
66   89         66
67   90         67
68   91         68
69   92         69
70   93         70
71   94         71
72   95         72
73   96         73
[1] "Using data from 2010 , session 1"
[1] "Crop name-to-number key:"
              num          name first_tube last_tube first_tube_alias
Maize-Soybean   1 Maize-Soybean          9        20                1
Switchgrass     2   Switchgrass         49        72               29
Miscanthus      3    Miscanthus         33        48               13
Prairie         4       Prairie         73        96               50
              last_tube_alias n_tubes
Maize-Soybean              12      12
Switchgrass                49      21
Miscanthus                 28      16
Prairie                    73      24
[1] "conditions for predicted data:"
   tube depth       Species
1     1     1   Switchgrass
2     2     1    Miscanthus
3     3     1       Prairie
4     4     1 Maize-Soybean
5     1     8   Switchgrass
6     2     8    Miscanthus
7     3     8       Prairie
8     4     8 Maize-Soybean
9     1    15   Switchgrass
10    2    15    Miscanthus
11    3    15       Prairie
12    4    15 Maize-Soybean
13    1    21   Switchgrass
14    2    21    Miscanthus
15    3    21       Prairie
16    4    21 Maize-Soybean
17    1    28   Switchgrass
18    2    28    Miscanthus
19    3    28       Prairie
20    4    28 Maize-Soybean
21    1    35   Switchgrass
22    2    35    Miscanthus
23    3    35       Prairie
24    4    35 Maize-Soybean
25    1    42   Switchgrass
26    2    42    Miscanthus
27    3    42       Prairie
28    4    42 Maize-Soybean
29    1    49   Switchgrass
30    2    49    Miscanthus
31    3    49       Prairie
32    4    49 Maize-Soybean
33    1    55   Switchgrass
34    2    55    Miscanthus
35    3    55       Prairie
36    4    55 Maize-Soybean
37    1    62   Switchgrass
38    2    62    Miscanthus
39    3    62       Prairie
40    4    62 Maize-Soybean
41    1    69   Switchgrass
42    2    69    Miscanthus
43    3    69       Prairie
44    4    69 Maize-Soybean
45    1    76   Switchgrass
46    2    76    Miscanthus
47    3    76       Prairie
48    4    76 Maize-Soybean
49    1    82   Switchgrass
50    2    82    Miscanthus
51    3    82       Prairie
52    4    82 Maize-Soybean
53    1    89   Switchgrass
54    2    89    Miscanthus
55    3    89       Prairie
56    4    89 Maize-Soybean
57    1    96   Switchgrass
58    2    96    Miscanthus
59    3    96       Prairie
60    4    96 Maize-Soybean
61    1   103   Switchgrass
62    2   103    Miscanthus
63    3   103       Prairie
64    4   103 Maize-Soybean
65    1   110   Switchgrass
66    2   110    Miscanthus
67    3   110       Prairie
68    4   110 Maize-Soybean
69    1   116   Switchgrass
70    2   116    Miscanthus
71    3   116       Prairie
72    4   116 Maize-Soybean
73    1   123   Switchgrass
74    2   123    Miscanthus
75    3   123       Prairie
76    4   123 Maize-Soybean
77    1   130   Switchgrass
78    2   130    Miscanthus
79    3   130       Prairie
80    4   130 Maize-Soybean

TRANSLATING MODEL 'mctd_foursurf' FROM Stan CODE TO C++ CODE NOW.
successful in parsing the Stan model 'mctd_foursurf'.
hash mismatch so recompiling; make sure Stan code ends with a blank line
OS: x86_64, darwin13.4.0; rstan: 2.14.1; Rcpp: 0.12.8; inline: 0.3.14 
 >> setting environment variables: 
PKG_LIBS =  -L'/Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/lib' -lStanHeaders
PKG_CPPFLAGS =   -I"/Library/Frameworks/R.framework/Versions/3.3/Resources/library/Rcpp/include/"  -I"/Library/Frameworks/R.framework/Versions/3.3/Resources/library/RcppEigen/include/"  -I"/Library/Frameworks/R.framework/Versions/3.3/Resources/library/RcppEigen/include/unsupported"  -I"/Library/Frameworks/R.framework/Versions/3.3/Resources/library/rstan/include/boost_not_in_BH" -I"/Library/Frameworks/R.framework/Versions/3.3/Resources/library/BH/include" -I"/Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/src/"  -I"/Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/"  -I"/Library/Frameworks/R.framework/Versions/3.3/Resources/library/rstan/include" -DEIGEN_NO_DEBUG  -DBOOST_RESULT_OF_USE_TR1 -DBOOST_NO_DECLTYPE -DBOOST_DISABLE_ASSERTS -DBOOST_NO_CXX11_RVALUE_REFERENCES
 >> Program source :

   1 : 
   2 : // includes from the plugin
   3 : 
   4 : 
   5 : // user includes
   6 : #define STAN__SERVICES__COMMAND_HPP// Code generated by Stan version 2.14
   7 : 
   8 : #include <stan/model/model_header.hpp>
   9 : 
  10 : namespace model23936388414e_mctd_foursurf_namespace {
  11 : 
  12 : using std::istream;
  13 : using std::string;
  14 : using std::stringstream;
  15 : using std::vector;
  16 : using stan::io::dump;
  17 : using stan::math::lgamma;
  18 : using stan::model::prob_grad;
  19 : using namespace stan::math;
  20 : 
  21 : typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
  22 : typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
  23 : typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;
  24 : 
  25 : static int current_statement_begin__;
  26 : 
  27 : class model23936388414e_mctd_foursurf : public prob_grad {
  28 : private:
  29 :     int N;
  30 :     int T;
  31 :     int C;
  32 :     vector<int> tube;
  33 :     vector<int> crop;
  34 :     vector_d depth;
  35 :     vector_d y;
  36 :     int N_pred;
  37 :     int T_pred;
  38 :     int C_pred;
  39 :     vector<int> crop_pred;
  40 :     vector<int> tube_pred;
  41 :     vector_d depth_pred;
  42 :     double sig_tube_prior_m;
  43 :     double sig_tube_prior_s;
  44 :     double sigma_prior_m;
  45 :     double sigma_prior_s;
  46 :     double intercept_prior_m;
  47 :     double intercept_prior_s;
  48 :     double b_depth_prior_m;
  49 :     double b_depth_prior_s;
  50 :     double loc_surface_prior_m;
  51 :     double loc_surface_prior_s;
  52 :     double scale_surface_prior_m;
  53 :     double scale_surface_prior_s;
  54 :     double loc_detect_prior_m;
  55 :     double loc_detect_prior_s;
  56 :     double scale_detect_prior_m;
  57 :     double scale_detect_prior_s;
  58 :     double depth_logmean;
  59 :     double depth_pred_max;
  60 :     vector<int> tube_crop_pred;
  61 :     vector_d log_depth_centered;
  62 :     vector_d log_depth_pred_centered;
  63 :     vector<int> y_logi;
  64 :     int n_pos;
  65 : public:
  66 :     model23936388414e_mctd_foursurf(stan::io::var_context& context__,
  67 :         std::ostream* pstream__ = 0)
  68 :         : prob_grad(0) {
  69 :         typedef boost::ecuyer1988 rng_t;
  70 :         rng_t base_rng(0);  // 0 seed default
  71 :         ctor_body(context__, base_rng, pstream__);
  72 :     }
  73 : 
  74 :     template <class RNG>
  75 :     model23936388414e_mctd_foursurf(stan::io::var_context& context__,
  76 :         RNG& base_rng__,
  77 :         std::ostream* pstream__ = 0)
  78 :         : prob_grad(0) {
  79 :         ctor_body(context__, base_rng__, pstream__);
  80 :     }
  81 : 
  82 :     template <class RNG>
  83 :     void ctor_body(stan::io::var_context& context__,
  84 :                    RNG& base_rng__,
  85 :                    std::ostream* pstream__) {
  86 :         current_statement_begin__ = -1;
  87 : 
  88 :         static const char* function__ = "model23936388414e_mctd_foursurf_namespace::model23936388414e_mctd_foursurf";
  89 :         (void) function__; // dummy call to supress warning
  90 :         size_t pos__;
  91 :         (void) pos__; // dummy call to supress warning
  92 :         std::vector<int> vals_i__;
  93 :         std::vector<double> vals_r__;
  94 :         double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
  95 :         (void) DUMMY_VAR__;  // suppress unused var warning
  96 : 
  97 :         // initialize member variables
  98 :         context__.validate_dims("data initialization", "N", "int", context__.to_vec());
  99 :         N = int(0);
 100 :         vals_i__ = context__.vals_i("N");
 101 :         pos__ = 0;
 102 :         N = vals_i__[pos__++];
 103 :         context__.validate_dims("data initialization", "T", "int", context__.to_vec());
 104 :         T = int(0);
 105 :         vals_i__ = context__.vals_i("T");
 106 :         pos__ = 0;
 107 :         T = vals_i__[pos__++];
 108 :         context__.validate_dims("data initialization", "C", "int", context__.to_vec());
 109 :         C = int(0);
 110 :         vals_i__ = context__.vals_i("C");
 111 :         pos__ = 0;
 112 :         C = vals_i__[pos__++];
 113 :         context__.validate_dims("data initialization", "tube", "int", context__.to_vec(N));
 114 :         validate_non_negative_index("tube", "N", N);
 115 :         tube = std::vector<int>(N,int(0));
 116 :         vals_i__ = context__.vals_i("tube");
 117 :         pos__ = 0;
 118 :         size_t tube_limit_0__ = N;
 119 :         for (size_t i_0__ = 0; i_0__ < tube_limit_0__; ++i_0__) {
 120 :             tube[i_0__] = vals_i__[pos__++];
 121 :         }
 122 :         context__.validate_dims("data initialization", "crop", "int", context__.to_vec(N));
 123 :         validate_non_negative_index("crop", "N", N);
 124 :         crop = std::vector<int>(N,int(0));
 125 :         vals_i__ = context__.vals_i("crop");
 126 :         pos__ = 0;
 127 :         size_t crop_limit_0__ = N;
 128 :         for (size_t i_0__ = 0; i_0__ < crop_limit_0__; ++i_0__) {
 129 :             crop[i_0__] = vals_i__[pos__++];
 130 :         }
 131 :         validate_non_negative_index("depth", "N", N);
 132 :         depth = vector_d(static_cast<Eigen::VectorXd::Index>(N));
 133 :         context__.validate_dims("data initialization", "depth", "vector_d", context__.to_vec(N));
 134 :         vals_r__ = context__.vals_r("depth");
 135 :         pos__ = 0;
 136 :         size_t depth_i_vec_lim__ = N;
 137 :         for (size_t i_vec__ = 0; i_vec__ < depth_i_vec_lim__; ++i_vec__) {
 138 :             depth[i_vec__] = vals_r__[pos__++];
 139 :         }
 140 :         validate_non_negative_index("y", "N", N);
 141 :         y = vector_d(static_cast<Eigen::VectorXd::Index>(N));
 142 :         context__.validate_dims("data initialization", "y", "vector_d", context__.to_vec(N));
 143 :         vals_r__ = context__.vals_r("y");
 144 :         pos__ = 0;
 145 :         size_t y_i_vec_lim__ = N;
 146 :         for (size_t i_vec__ = 0; i_vec__ < y_i_vec_lim__; ++i_vec__) {
 147 :             y[i_vec__] = vals_r__[pos__++];
 148 :         }
 149 :         context__.validate_dims("data initialization", "N_pred", "int", context__.to_vec());
 150 :         N_pred = int(0);
 151 :         vals_i__ = context__.vals_i("N_pred");
 152 :         pos__ = 0;
 153 :         N_pred = vals_i__[pos__++];
 154 :         context__.validate_dims("data initialization", "T_pred", "int", context__.to_vec());
 155 :         T_pred = int(0);
 156 :         vals_i__ = context__.vals_i("T_pred");
 157 :         pos__ = 0;
 158 :         T_pred = vals_i__[pos__++];
 159 :         context__.validate_dims("data initialization", "C_pred", "int", context__.to_vec());
 160 :         C_pred = int(0);
 161 :         vals_i__ = context__.vals_i("C_pred");
 162 :         pos__ = 0;
 163 :         C_pred = vals_i__[pos__++];
 164 :         context__.validate_dims("data initialization", "crop_pred", "int", context__.to_vec(N_pred));
 165 :         validate_non_negative_index("crop_pred", "N_pred", N_pred);
 166 :         crop_pred = std::vector<int>(N_pred,int(0));
 167 :         vals_i__ = context__.vals_i("crop_pred");
 168 :         pos__ = 0;
 169 :         size_t crop_pred_limit_0__ = N_pred;
 170 :         for (size_t i_0__ = 0; i_0__ < crop_pred_limit_0__; ++i_0__) {
 171 :             crop_pred[i_0__] = vals_i__[pos__++];
 172 :         }
 173 :         context__.validate_dims("data initialization", "tube_pred", "int", context__.to_vec(N_pred));
 174 :         validate_non_negative_index("tube_pred", "N_pred", N_pred);
 175 :         tube_pred = std::vector<int>(N_pred,int(0));
 176 :         vals_i__ = context__.vals_i("tube_pred");
 177 :         pos__ = 0;
 178 :         size_t tube_pred_limit_0__ = N_pred;
 179 :         for (size_t i_0__ = 0; i_0__ < tube_pred_limit_0__; ++i_0__) {
 180 :             tube_pred[i_0__] = vals_i__[pos__++];
 181 :         }
 182 :         validate_non_negative_index("depth_pred", "N_pred", N_pred);
 183 :         depth_pred = vector_d(static_cast<Eigen::VectorXd::Index>(N_pred));
 184 :         context__.validate_dims("data initialization", "depth_pred", "vector_d", context__.to_vec(N_pred));
 185 :         vals_r__ = context__.vals_r("depth_pred");
 186 :         pos__ = 0;
 187 :         size_t depth_pred_i_vec_lim__ = N_pred;
 188 :         for (size_t i_vec__ = 0; i_vec__ < depth_pred_i_vec_lim__; ++i_vec__) {
 189 :             depth_pred[i_vec__] = vals_r__[pos__++];
 190 :         }
 191 :         context__.validate_dims("data initialization", "sig_tube_prior_m", "double", context__.to_vec());
 192 :         sig_tube_prior_m = double(0);
 193 :         vals_r__ = context__.vals_r("sig_tube_prior_m");
 194 :         pos__ = 0;
 195 :         sig_tube_prior_m = vals_r__[pos__++];
 196 :         context__.validate_dims("data initialization", "sig_tube_prior_s", "double", context__.to_vec());
 197 :         sig_tube_prior_s = double(0);
 198 :         vals_r__ = context__.vals_r("sig_tube_prior_s");
 199 :         pos__ = 0;
 200 :         sig_tube_prior_s = vals_r__[pos__++];
 201 :         context__.validate_dims("data initialization", "sigma_prior_m", "double", context__.to_vec());
 202 :         sigma_prior_m = double(0);
 203 :         vals_r__ = context__.vals_r("sigma_prior_m");
 204 :         pos__ = 0;
 205 :         sigma_prior_m = vals_r__[pos__++];
 206 :         context__.validate_dims("data initialization", "sigma_prior_s", "double", context__.to_vec());
 207 :         sigma_prior_s = double(0);
 208 :         vals_r__ = context__.vals_r("sigma_prior_s");
 209 :         pos__ = 0;
 210 :         sigma_prior_s = vals_r__[pos__++];
 211 :         context__.validate_dims("data initialization", "intercept_prior_m", "double", context__.to_vec());
 212 :         intercept_prior_m = double(0);
 213 :         vals_r__ = context__.vals_r("intercept_prior_m");
 214 :         pos__ = 0;
 215 :         intercept_prior_m = vals_r__[pos__++];
 216 :         context__.validate_dims("data initialization", "intercept_prior_s", "double", context__.to_vec());
 217 :         intercept_prior_s = double(0);
 218 :         vals_r__ = context__.vals_r("intercept_prior_s");
 219 :         pos__ = 0;
 220 :         intercept_prior_s = vals_r__[pos__++];
 221 :         context__.validate_dims("data initialization", "b_depth_prior_m", "double", context__.to_vec());
 222 :         b_depth_prior_m = double(0);
 223 :         vals_r__ = context__.vals_r("b_depth_prior_m");
 224 :         pos__ = 0;
 225 :         b_depth_prior_m = vals_r__[pos__++];
 226 :         context__.validate_dims("data initialization", "b_depth_prior_s", "double", context__.to_vec());
 227 :         b_depth_prior_s = double(0);
 228 :         vals_r__ = context__.vals_r("b_depth_prior_s");
 229 :         pos__ = 0;
 230 :         b_depth_prior_s = vals_r__[pos__++];
 231 :         context__.validate_dims("data initialization", "loc_surface_prior_m", "double", context__.to_vec());
 232 :         loc_surface_prior_m = double(0);
 233 :         vals_r__ = context__.vals_r("loc_surface_prior_m");
 234 :         pos__ = 0;
 235 :         loc_surface_prior_m = vals_r__[pos__++];
 236 :         context__.validate_dims("data initialization", "loc_surface_prior_s", "double", context__.to_vec());
 237 :         loc_surface_prior_s = double(0);
 238 :         vals_r__ = context__.vals_r("loc_surface_prior_s");
 239 :         pos__ = 0;
 240 :         loc_surface_prior_s = vals_r__[pos__++];
 241 :         context__.validate_dims("data initialization", "scale_surface_prior_m", "double", context__.to_vec());
 242 :         scale_surface_prior_m = double(0);
 243 :         vals_r__ = context__.vals_r("scale_surface_prior_m");
 244 :         pos__ = 0;
 245 :         scale_surface_prior_m = vals_r__[pos__++];
 246 :         context__.validate_dims("data initialization", "scale_surface_prior_s", "double", context__.to_vec());
 247 :         scale_surface_prior_s = double(0);
 248 :         vals_r__ = context__.vals_r("scale_surface_prior_s");
 249 :         pos__ = 0;
 250 :         scale_surface_prior_s = vals_r__[pos__++];
 251 :         context__.validate_dims("data initialization", "loc_detect_prior_m", "double", context__.to_vec());
 252 :         loc_detect_prior_m = double(0);
 253 :         vals_r__ = context__.vals_r("loc_detect_prior_m");
 254 :         pos__ = 0;
 255 :         loc_detect_prior_m = vals_r__[pos__++];
 256 :         context__.validate_dims("data initialization", "loc_detect_prior_s", "double", context__.to_vec());
 257 :         loc_detect_prior_s = double(0);
 258 :         vals_r__ = context__.vals_r("loc_detect_prior_s");
 259 :         pos__ = 0;
 260 :         loc_detect_prior_s = vals_r__[pos__++];
 261 :         context__.validate_dims("data initialization", "scale_detect_prior_m", "double", context__.to_vec());
 262 :         scale_detect_prior_m = double(0);
 263 :         vals_r__ = context__.vals_r("scale_detect_prior_m");
 264 :         pos__ = 0;
 265 :         scale_detect_prior_m = vals_r__[pos__++];
 266 :         context__.validate_dims("data initialization", "scale_detect_prior_s", "double", context__.to_vec());
 267 :         scale_detect_prior_s = double(0);
 268 :         vals_r__ = context__.vals_r("scale_detect_prior_s");
 269 :         pos__ = 0;
 270 :         scale_detect_prior_s = vals_r__[pos__++];
 271 : 
 272 :         // validate, data variables
 273 :         check_greater_or_equal(function__,"N",N,0);
 274 :         check_greater_or_equal(function__,"T",T,0);
 275 :         check_greater_or_equal(function__,"C",C,0);
 276 :         for (int k0__ = 0; k0__ < N; ++k0__) {
 277 :             check_greater_or_equal(function__,"tube[k0__]",tube[k0__],0);
 278 :             check_less_or_equal(function__,"tube[k0__]",tube[k0__],T);
 279 :         }
 280 :         for (int k0__ = 0; k0__ < N; ++k0__) {
 281 :             check_greater_or_equal(function__,"crop[k0__]",crop[k0__],1);
 282 :             check_less_or_equal(function__,"crop[k0__]",crop[k0__],C);
 283 :         }
 284 :         check_greater_or_equal(function__,"depth",depth,0);
 285 :         check_greater_or_equal(function__,"y",y,0);
 286 :         check_greater_or_equal(function__,"N_pred",N_pred,0);
 287 :         check_greater_or_equal(function__,"T_pred",T_pred,0);
 288 :         check_greater_or_equal(function__,"C_pred",C_pred,0);
 289 :         for (int k0__ = 0; k0__ < N_pred; ++k0__) {
 290 :             check_greater_or_equal(function__,"crop_pred[k0__]",crop_pred[k0__],0);
 291 :             check_less_or_equal(function__,"crop_pred[k0__]",crop_pred[k0__],C_pred);
 292 :         }
 293 :         for (int k0__ = 0; k0__ < N_pred; ++k0__) {
 294 :             check_greater_or_equal(function__,"tube_pred[k0__]",tube_pred[k0__],0);
 295 :             check_less_or_equal(function__,"tube_pred[k0__]",tube_pred[k0__],T_pred);
 296 :         }
 297 :         check_greater_or_equal(function__,"depth_pred",depth_pred,0);
 298 :         check_greater_or_equal(function__,"sig_tube_prior_s",sig_tube_prior_s,0);
 299 :         check_greater_or_equal(function__,"sigma_prior_s",sigma_prior_s,0);
 300 :         check_greater_or_equal(function__,"intercept_prior_s",intercept_prior_s,0);
 301 :         check_greater_or_equal(function__,"b_depth_prior_s",b_depth_prior_s,0);
 302 :         check_greater_or_equal(function__,"loc_surface_prior_s",loc_surface_prior_s,0);
 303 :         check_greater_or_equal(function__,"scale_surface_prior_s",scale_surface_prior_s,0);
 304 :         check_greater_or_equal(function__,"loc_detect_prior_s",loc_detect_prior_s,0);
 305 :         check_greater_or_equal(function__,"scale_detect_prior_s",scale_detect_prior_s,0);
 306 :         // initialize data variables
 307 :         depth_logmean = double(0);
 308 :         stan::math::fill(depth_logmean,DUMMY_VAR__);
 309 :         depth_pred_max = double(0);
 310 :         stan::math::fill(depth_pred_max,DUMMY_VAR__);
 311 :         validate_non_negative_index("tube_crop_pred", "T_pred", T_pred);
 312 :         tube_crop_pred = std::vector<int>(T_pred,int(0));
 313 :         stan::math::fill(tube_crop_pred, std::numeric_limits<int>::min());
 314 :         validate_non_negative_index("log_depth_centered", "N", N);
 315 :         log_depth_centered = vector_d(static_cast<Eigen::VectorXd::Index>(N));
 316 :         stan::math::fill(log_depth_centered,DUMMY_VAR__);
 317 :         validate_non_negative_index("log_depth_pred_centered", "N_pred", N_pred);
 318 :         log_depth_pred_centered = vector_d(static_cast<Eigen::VectorXd::Index>(N_pred));
 319 :         stan::math::fill(log_depth_pred_centered,DUMMY_VAR__);
 320 :         validate_non_negative_index("y_logi", "N", N);
 321 :         y_logi = std::vector<int>(N,int(0));
 322 :         stan::math::fill(y_logi, std::numeric_limits<int>::min());
 323 :         n_pos = int(0);
 324 :         stan::math::fill(n_pos, std::numeric_limits<int>::min());
 325 : 
 326 :         try {
 327 :             current_statement_begin__ = 68;
 328 :             stan::math::assign(depth_logmean, log(mean(depth)));
 329 :             current_statement_begin__ = 69;
 330 :             stan::math::assign(depth_pred_max, max(depth_pred));
 331 :             current_statement_begin__ = 70;
 332 :             for (int n = 1; n <= N; ++n) {
 333 : 
 334 :                 current_statement_begin__ = 71;
 335 :                 stan::math::assign(get_base1_lhs(log_depth_centered,n,"log_depth_centered",1), (log(get_base1(depth,n,"depth",1)) - depth_logmean));
 336 :                 current_statement_begin__ = 72;
 337 :                 stan::math::assign(get_base1_lhs(y_logi,n,"y_logi",1), int_step(get_base1(y,n,"y",1)));
 338 :             }
 339 :             current_statement_begin__ = 74;
 340 :             stan::math::assign(n_pos, sum(y_logi));
 341 :             current_statement_begin__ = 76;
 342 :             if (as_bool((primitive_value(logical_neq(sum(stan::model::rvalue(y_logi, stan::model::cons_list(stan::model::index_min_max((n_pos + 1), N), stan::model::nil_index_list()), "y_logi")),0)) || primitive_value(logical_neq(sum(stan::model::rvalue(y_logi, stan::model::cons_list(stan::model::index_min_max(1, n_pos), stan::model::nil_index_list()), "y_logi")),n_pos))))) {
 343 : 
 344 :                 current_statement_begin__ = 77;
 345 :                 std::stringstream errmsg_stream__;
 346 :                 errmsg_stream__ << "all observations with y==0 must appear at the end of the dataset";
 347 :                 throw std::domain_error(errmsg_stream__.str());
 348 :             }
 349 :             current_statement_begin__ = 80;
 350 :             for (int n = 1; n <= N_pred; ++n) {
 351 : 
 352 :                 current_statement_begin__ = 81;
 353 :                 stan::math::assign(get_base1_lhs(tube_crop_pred,get_base1(tube_pred,n,"tube_pred",1),"tube_crop_pred",1), get_base1(crop_pred,n,"crop_pred",1));
 354 :                 current_statement_begin__ = 82;
 355 :                 stan::math::assign(get_base1_lhs(log_depth_pred_centered,n,"log_depth_pred_centered",1), (log(get_base1(depth_pred,n,"depth_pred",1)) - depth_logmean));
 356 :             }
 357 :         } catch (const std::exception& e) {
 358 :             stan::lang::rethrow_located(e,current_statement_begin__);
 359 :             // Next line prevents compiler griping about no return
 360 :             throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
 361 :         }
 362 : 
 363 :         // validate transformed data
 364 :         for (int k0__ = 0; k0__ < T_pred; ++k0__) {
 365 :             check_greater_or_equal(function__,"tube_crop_pred[k0__]",tube_crop_pred[k0__],1);
 366 :             check_less_or_equal(function__,"tube_crop_pred[k0__]",tube_crop_pred[k0__],C_pred);
 367 :         }
 368 :         for (int k0__ = 0; k0__ < N; ++k0__) {
 369 :             check_greater_or_equal(function__,"y_logi[k0__]",y_logi[k0__],0);
 370 :             check_less_or_equal(function__,"y_logi[k0__]",y_logi[k0__],1);
 371 :         }
 372 :         check_greater_or_equal(function__,"n_pos",n_pos,0);
 373 :         check_less_or_equal(function__,"n_pos",n_pos,N);
 374 : 
 375 :         // set parameter ranges
 376 :         num_params_r__ = 0U;
 377 :         param_ranges_i__.clear();
 378 :         ++num_params_r__;
 379 :         ++num_params_r__;
 380 :         num_params_r__ += C;
 381 :         num_params_r__ += C;
 382 :         num_params_r__ += C;
 383 :         num_params_r__ += C;
 384 :         num_params_r__ += T;
 385 :         ++num_params_r__;
 386 :         num_params_r__ += C;
 387 :     }
 388 : 
 389 :     ~model23936388414e_mctd_foursurf() { }
 390 : 
 391 : 
 392 :     void transform_inits(const stan::io::var_context& context__,
 393 :                          std::vector<int>& params_i__,
 394 :                          std::vector<double>& params_r__,
 395 :                          std::ostream* pstream__) const {
 396 :         stan::io::writer<double> writer__(params_r__,params_i__);
 397 :         size_t pos__;
 398 :         (void) pos__; // dummy call to supress warning
 399 :         std::vector<double> vals_r__;
 400 :         std::vector<int> vals_i__;
 401 : 
 402 :         if (!(context__.contains_r("loc_detect")))
 403 :             throw std::runtime_error("variable loc_detect missing");
 404 :         vals_r__ = context__.vals_r("loc_detect");
 405 :         pos__ = 0U;
 406 :         context__.validate_dims("initialization", "loc_detect", "double", context__.to_vec());
 407 :         // generate_declaration loc_detect
 408 :         double loc_detect(0);
 409 :         loc_detect = vals_r__[pos__++];
 410 :         try {
 411 :             writer__.scalar_unconstrain(loc_detect);
 412 :         } catch (const std::exception& e) { 
 413 :             throw std::runtime_error(std::string("Error transforming variable loc_detect: ") + e.what());
 414 :         }
 415 : 
 416 :         if (!(context__.contains_r("scale_detect")))
 417 :             throw std::runtime_error("variable scale_detect missing");
 418 :         vals_r__ = context__.vals_r("scale_detect");
 419 :         pos__ = 0U;
 420 :         context__.validate_dims("initialization", "scale_detect", "double", context__.to_vec());
 421 :         // generate_declaration scale_detect
 422 :         double scale_detect(0);
 423 :         scale_detect = vals_r__[pos__++];
 424 :         try {
 425 :             writer__.scalar_lb_unconstrain(0,scale_detect);
 426 :         } catch (const std::exception& e) { 
 427 :             throw std::runtime_error(std::string("Error transforming variable scale_detect: ") + e.what());
 428 :         }
 429 : 
 430 :         if (!(context__.contains_r("loc_surface")))
 431 :             throw std::runtime_error("variable loc_surface missing");
 432 :         vals_r__ = context__.vals_r("loc_surface");
 433 :         pos__ = 0U;
 434 :         context__.validate_dims("initialization", "loc_surface", "vector_d", context__.to_vec(C));
 435 :         // generate_declaration loc_surface
 436 :         vector_d loc_surface(static_cast<Eigen::VectorXd::Index>(C));
 437 :         for (int j1__ = 0U; j1__ < C; ++j1__)
 438 :             loc_surface(j1__) = vals_r__[pos__++];
 439 :         try {
 440 :             writer__.vector_unconstrain(loc_surface);
 441 :         } catch (const std::exception& e) { 
 442 :             throw std::runtime_error(std::string("Error transforming variable loc_surface: ") + e.what());
 443 :         }
 444 : 
 445 :         if (!(context__.contains_r("scale_surface")))
 446 :             throw std::runtime_error("variable scale_surface missing");
 447 :         vals_r__ = context__.vals_r("scale_surface");
 448 :         pos__ = 0U;
 449 :         context__.validate_dims("initialization", "scale_surface", "vector_d", context__.to_vec(C));
 450 :         // generate_declaration scale_surface
 451 :         vector_d scale_surface(static_cast<Eigen::VectorXd::Index>(C));
 452 :         for (int j1__ = 0U; j1__ < C; ++j1__)
 453 :             scale_surface(j1__) = vals_r__[pos__++];
 454 :         try {
 455 :             writer__.vector_lb_unconstrain(0,scale_surface);
 456 :         } catch (const std::exception& e) { 
 457 :             throw std::runtime_error(std::string("Error transforming variable scale_surface: ") + e.what());
 458 :         }
 459 : 
 460 :         if (!(context__.contains_r("intercept")))
 461 :             throw std::runtime_error("variable intercept missing");
 462 :         vals_r__ = context__.vals_r("intercept");
 463 :         pos__ = 0U;
 464 :         context__.validate_dims("initialization", "intercept", "vector_d", context__.to_vec(C));
 465 :         // generate_declaration intercept
 466 :         vector_d intercept(static_cast<Eigen::VectorXd::Index>(C));
 467 :         for (int j1__ = 0U; j1__ < C; ++j1__)
 468 :             intercept(j1__) = vals_r__[pos__++];
 469 :         try {
 470 :             writer__.vector_unconstrain(intercept);
 471 :         } catch (const std::exception& e) { 
 472 :             throw std::runtime_error(std::string("Error transforming variable intercept: ") + e.what());
 473 :         }
 474 : 
 475 :         if (!(context__.contains_r("b_depth")))
 476 :             throw std::runtime_error("variable b_depth missing");
 477 :         vals_r__ = context__.vals_r("b_depth");
 478 :         pos__ = 0U;
 479 :         context__.validate_dims("initialization", "b_depth", "vector_d", context__.to_vec(C));
 480 :         // generate_declaration b_depth
 481 :         vector_d b_depth(static_cast<Eigen::VectorXd::Index>(C));
 482 :         for (int j1__ = 0U; j1__ < C; ++j1__)
 483 :             b_depth(j1__) = vals_r__[pos__++];
 484 :         try {
 485 :             writer__.vector_unconstrain(b_depth);
 486 :         } catch (const std::exception& e) { 
 487 :             throw std::runtime_error(std::string("Error transforming variable b_depth: ") + e.what());
 488 :         }
 489 : 
 490 :         if (!(context__.contains_r("b_tube")))
 491 :             throw std::runtime_error("variable b_tube missing");
 492 :         vals_r__ = context__.vals_r("b_tube");
 493 :         pos__ = 0U;
 494 :         context__.validate_dims("initialization", "b_tube", "vector_d", context__.to_vec(T));
 495 :         // generate_declaration b_tube
 496 :         vector_d b_tube(static_cast<Eigen::VectorXd::Index>(T));
 497 :         for (int j1__ = 0U; j1__ < T; ++j1__)
 498 :             b_tube(j1__) = vals_r__[pos__++];
 499 :         try {
 500 :             writer__.vector_unconstrain(b_tube);
 501 :         } catch (const std::exception& e) { 
 502 :             throw std::runtime_error(std::string("Error transforming variable b_tube: ") + e.what());
 503 :         }
 504 : 
 505 :         if (!(context__.contains_r("sig_tube")))
 506 :             throw std::runtime_error("variable sig_tube missing");
 507 :         vals_r__ = context__.vals_r("sig_tube");
 508 :         pos__ = 0U;
 509 :         context__.validate_dims("initialization", "sig_tube", "double", context__.to_vec());
 510 :         // generate_declaration sig_tube
 511 :         double sig_tube(0);
 512 :         sig_tube = vals_r__[pos__++];
 513 :         try {
 514 :             writer__.scalar_lb_unconstrain(0,sig_tube);
 515 :         } catch (const std::exception& e) { 
 516 :             throw std::runtime_error(std::string("Error transforming variable sig_tube: ") + e.what());
 517 :         }
 518 : 
 519 :         if (!(context__.contains_r("sigma")))
 520 :             throw std::runtime_error("variable sigma missing");
 521 :         vals_r__ = context__.vals_r("sigma");
 522 :         pos__ = 0U;
 523 :         context__.validate_dims("initialization", "sigma", "vector_d", context__.to_vec(C));
 524 :         // generate_declaration sigma
 525 :         vector_d sigma(static_cast<Eigen::VectorXd::Index>(C));
 526 :         for (int j1__ = 0U; j1__ < C; ++j1__)
 527 :             sigma(j1__) = vals_r__[pos__++];
 528 :         try {
 529 :             writer__.vector_lb_unconstrain(0,sigma);
 530 :         } catch (const std::exception& e) { 
 531 :             throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
 532 :         }
 533 : 
 534 :         params_r__ = writer__.data_r();
 535 :         params_i__ = writer__.data_i();
 536 :     }
 537 : 
 538 :     void transform_inits(const stan::io::var_context& context,
 539 :                          Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
 540 :                          std::ostream* pstream__) const {
 541 :       std::vector<double> params_r_vec;
 542 :       std::vector<int> params_i_vec;
 543 :       transform_inits(context, params_i_vec, params_r_vec, pstream__);
 544 :       params_r.resize(params_r_vec.size());
 545 :       for (int i = 0; i < params_r.size(); ++i)
 546 :         params_r(i) = params_r_vec[i];
 547 :     }
 548 : 
 549 : 
 550 :     template <bool propto__, bool jacobian__, typename T__>
 551 :     T__ log_prob(vector<T__>& params_r__,
 552 :                  vector<int>& params_i__,
 553 :                  std::ostream* pstream__ = 0) const {
 554 : 
 555 :         T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 556 :         (void) DUMMY_VAR__;  // suppress unused var warning
 557 : 
 558 :         T__ lp__(0.0);
 559 :         stan::math::accumulator<T__> lp_accum__;
 560 : 
 561 :         // model parameters
 562 :         stan::io::reader<T__> in__(params_r__,params_i__);
 563 : 
 564 :         T__ loc_detect;
 565 :         (void) loc_detect;  // dummy to suppress unused var warning
 566 :         if (jacobian__)
 567 :             loc_detect = in__.scalar_constrain(lp__);
 568 :         else
 569 :             loc_detect = in__.scalar_constrain();
 570 : 
 571 :         T__ scale_detect;
 572 :         (void) scale_detect;  // dummy to suppress unused var warning
 573 :         if (jacobian__)
 574 :             scale_detect = in__.scalar_lb_constrain(0,lp__);
 575 :         else
 576 :             scale_detect = in__.scalar_lb_constrain(0);
 577 : 
 578 :         Eigen::Matrix<T__,Eigen::Dynamic,1>  loc_surface;
 579 :         (void) loc_surface;  // dummy to suppress unused var warning
 580 :         if (jacobian__)
 581 :             loc_surface = in__.vector_constrain(C,lp__);
 582 :         else
 583 :             loc_surface = in__.vector_constrain(C);
 584 : 
 585 :         Eigen::Matrix<T__,Eigen::Dynamic,1>  scale_surface;
 586 :         (void) scale_surface;  // dummy to suppress unused var warning
 587 :         if (jacobian__)
 588 :             scale_surface = in__.vector_lb_constrain(0,C,lp__);
 589 :         else
 590 :             scale_surface = in__.vector_lb_constrain(0,C);
 591 : 
 592 :         Eigen::Matrix<T__,Eigen::Dynamic,1>  intercept;
 593 :         (void) intercept;  // dummy to suppress unused var warning
 594 :         if (jacobian__)
 595 :             intercept = in__.vector_constrain(C,lp__);
 596 :         else
 597 :             intercept = in__.vector_constrain(C);
 598 : 
 599 :         Eigen::Matrix<T__,Eigen::Dynamic,1>  b_depth;
 600 :         (void) b_depth;  // dummy to suppress unused var warning
 601 :         if (jacobian__)
 602 :             b_depth = in__.vector_constrain(C,lp__);
 603 :         else
 604 :             b_depth = in__.vector_constrain(C);
 605 : 
 606 :         Eigen::Matrix<T__,Eigen::Dynamic,1>  b_tube;
 607 :         (void) b_tube;  // dummy to suppress unused var warning
 608 :         if (jacobian__)
 609 :             b_tube = in__.vector_constrain(T,lp__);
 610 :         else
 611 :             b_tube = in__.vector_constrain(T);
 612 : 
 613 :         T__ sig_tube;
 614 :         (void) sig_tube;  // dummy to suppress unused var warning
 615 :         if (jacobian__)
 616 :             sig_tube = in__.scalar_lb_constrain(0,lp__);
 617 :         else
 618 :             sig_tube = in__.scalar_lb_constrain(0);
 619 : 
 620 :         Eigen::Matrix<T__,Eigen::Dynamic,1>  sigma;
 621 :         (void) sigma;  // dummy to suppress unused var warning
 622 :         if (jacobian__)
 623 :             sigma = in__.vector_lb_constrain(0,C,lp__);
 624 :         else
 625 :             sigma = in__.vector_lb_constrain(0,C);
 626 : 
 627 : 
 628 :         // transformed parameters
 629 :         Eigen::Matrix<T__,Eigen::Dynamic,1>  mu(static_cast<Eigen::VectorXd::Index>(N));
 630 :         (void) mu;  // dummy to suppress unused var warning
 631 :         stan::math::initialize(mu, DUMMY_VAR__);
 632 :         stan::math::fill(mu,DUMMY_VAR__);
 633 :         Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_obs(static_cast<Eigen::VectorXd::Index>(N));
 634 :         (void) mu_obs;  // dummy to suppress unused var warning
 635 :         stan::math::initialize(mu_obs, DUMMY_VAR__);
 636 :         stan::math::fill(mu_obs,DUMMY_VAR__);
 637 :         Eigen::Matrix<T__,Eigen::Dynamic,1>  detect_odds(static_cast<Eigen::VectorXd::Index>(N));
 638 :         (void) detect_odds;  // dummy to suppress unused var warning
 639 :         stan::math::initialize(detect_odds, DUMMY_VAR__);
 640 :         stan::math::fill(detect_odds,DUMMY_VAR__);
 641 : 
 642 : 
 643 :         try {
 644 :             current_statement_begin__ = 116;
 645 :             stan::math::assign(mu, add(add(stan::model::rvalue(intercept, stan::model::cons_list(stan::model::index_multi(crop), stan::model::nil_index_list()), "intercept"),stan::model::rvalue(b_tube, stan::model::cons_list(stan::model::index_multi(tube), stan::model::nil_index_list()), "b_tube")),elt_multiply(stan::model::rvalue(b_depth, stan::model::cons_list(stan::model::index_multi(crop), stan::model::nil_index_list()), "b_depth"),log_depth_centered)));
 646 :             current_statement_begin__ = 119;
 647 :             stan::math::assign(mu_obs, add(mu,log_inv_logit(elt_divide(subtract(depth,stan::model::rvalue(loc_surface, stan::model::cons_list(stan::model::index_multi(crop), stan::model::nil_index_list()), "loc_surface")),stan::model::rvalue(scale_surface, stan::model::cons_list(stan::model::index_multi(crop), stan::model::nil_index_list()), "scale_surface")))));
 648 :             current_statement_begin__ = 122;
 649 :             stan::math::assign(detect_odds, divide(subtract(mu_obs,loc_detect),scale_detect));
 650 :         } catch (const std::exception& e) {
 651 :             stan::lang::rethrow_located(e,current_statement_begin__);
 652 :             // Next line prevents compiler griping about no return
 653 :             throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
 654 :         }
 655 : 
 656 :         // validate transformed parameters
 657 :         for (int i0__ = 0; i0__ < N; ++i0__) {
 658 :             if (stan::math::is_uninitialized(mu(i0__))) {
 659 :                 std::stringstream msg__;
 660 :                 msg__ << "Undefined transformed parameter: mu" << '[' << i0__ << ']';
 661 :                 throw std::runtime_error(msg__.str());
 662 :             }
 663 :         }
 664 :         for (int i0__ = 0; i0__ < N; ++i0__) {
 665 :             if (stan::math::is_uninitialized(mu_obs(i0__))) {
 666 :                 std::stringstream msg__;
 667 :                 msg__ << "Undefined transformed parameter: mu_obs" << '[' << i0__ << ']';
 668 :                 throw std::runtime_error(msg__.str());
 669 :             }
 670 :         }
 671 :         for (int i0__ = 0; i0__ < N; ++i0__) {
 672 :             if (stan::math::is_uninitialized(detect_odds(i0__))) {
 673 :                 std::stringstream msg__;
 674 :                 msg__ << "Undefined transformed parameter: detect_odds" << '[' << i0__ << ']';
 675 :                 throw std::runtime_error(msg__.str());
 676 :             }
 677 :         }
 678 : 
 679 :         const char* function__ = "validate transformed params";
 680 :         (void) function__;  // dummy to suppress unused var warning
 681 : 
 682 :         // model body
 683 :         try {
 684 : 
 685 :             current_statement_begin__ = 127;
 686 :             lp_accum__.add(normal_log<propto__>(sig_tube, sig_tube_prior_m, sig_tube_prior_s));
 687 :             current_statement_begin__ = 128;
 688 :             lp_accum__.add(normal_log<propto__>(b_tube, 0, sig_tube));
 689 :             current_statement_begin__ = 129;
 690 :             lp_accum__.add(normal_log<propto__>(sigma, sigma_prior_m, sigma_prior_s));
 691 :             current_statement_begin__ = 130;
 692 :             lp_accum__.add(normal_log<propto__>(intercept, intercept_prior_m, intercept_prior_s));
 693 :             current_statement_begin__ = 131;
 694 :             lp_accum__.add(normal_log<propto__>(b_depth, b_depth_prior_m, b_depth_prior_s));
 695 :             current_statement_begin__ = 132;
 696 :             lp_accum__.add(normal_log<propto__>(loc_surface, loc_surface_prior_m, loc_surface_prior_s));
 697 :             current_statement_begin__ = 133;
 698 :             lp_accum__.add(normal_log<propto__>(scale_surface, scale_surface_prior_m, scale_surface_prior_s));
 699 :             current_statement_begin__ = 134;
 700 :             lp_accum__.add(normal_log<propto__>(loc_detect, loc_detect_prior_m, loc_detect_prior_s));
 701 :             current_statement_begin__ = 135;
 702 :             lp_accum__.add(normal_log<propto__>(scale_detect, scale_detect_prior_m, scale_detect_prior_s));
 703 :             current_statement_begin__ = 138;
 704 :             lp_accum__.add(bernoulli_logit_log<propto__>(y_logi, detect_odds));
 705 :             current_statement_begin__ = 139;
 706 :             lp_accum__.add(lognormal_log<propto__>(head(y,n_pos), head(mu_obs,n_pos), stan::model::rvalue(sigma, stan::model::cons_list(stan::model::index_multi(head(crop,n_pos)), stan::model::nil_index_list()), "sigma")));
 707 :         } catch (const std::exception& e) {
 708 :             stan::lang::rethrow_located(e,current_statement_begin__);
 709 :             // Next line prevents compiler griping about no return
 710 :             throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
 711 :         }
 712 : 
 713 :         lp_accum__.add(lp__);
 714 :         return lp_accum__.sum();
 715 : 
 716 :     } // log_prob()
 717 : 
 718 :     template <bool propto, bool jacobian, typename T_>
 719 :     T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
 720 :                std::ostream* pstream = 0) const {
 721 :       std::vector<T_> vec_params_r;
 722 :       vec_params_r.reserve(params_r.size());
 723 :       for (int i = 0; i < params_r.size(); ++i)
 724 :         vec_params_r.push_back(params_r(i));
 725 :       std::vector<int> vec_params_i;
 726 :       return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
 727 :     }
 728 : 
 729 : 
 730 :     void get_param_names(std::vector<std::string>& names__) const {
 731 :         names__.resize(0);
 732 :         names__.push_back("loc_detect");
 733 :         names__.push_back("scale_detect");
 734 :         names__.push_back("loc_surface");
 735 :         names__.push_back("scale_surface");
 736 :         names__.push_back("intercept");
 737 :         names__.push_back("b_depth");
 738 :         names__.push_back("b_tube");
 739 :         names__.push_back("sig_tube");
 740 :         names__.push_back("sigma");
 741 :         names__.push_back("mu");
 742 :         names__.push_back("mu_obs");
 743 :         names__.push_back("detect_odds");
 744 :         names__.push_back("b_tube_pred");
 745 :         names__.push_back("pred_tot");
 746 :         names__.push_back("mu_pred");
 747 :         names__.push_back("mu_obs_pred");
 748 :         names__.push_back("detect_odds_pred");
 749 :         names__.push_back("y_pred");
 750 :         names__.push_back("crop_tot");
 751 :         names__.push_back("crop_tot_diff");
 752 :         names__.push_back("crop_int_diff");
 753 :         names__.push_back("crop_bdepth_diff");
 754 :     }
 755 : 
 756 : 
 757 :     void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
 758 :         dimss__.resize(0);
 759 :         std::vector<size_t> dims__;
 760 :         dims__.resize(0);
 761 :         dimss__.push_back(dims__);
 762 :         dims__.resize(0);
 763 :         dimss__.push_back(dims__);
 764 :         dims__.resize(0);
 765 :         dims__.push_back(C);
 766 :         dimss__.push_back(dims__);
 767 :         dims__.resize(0);
 768 :         dims__.push_back(C);
 769 :         dimss__.push_back(dims__);
 770 :         dims__.resize(0);
 771 :         dims__.push_back(C);
 772 :         dimss__.push_back(dims__);
 773 :         dims__.resize(0);
 774 :         dims__.push_back(C);
 775 :         dimss__.push_back(dims__);
 776 :         dims__.resize(0);
 777 :         dims__.push_back(T);
 778 :         dimss__.push_back(dims__);
 779 :         dims__.resize(0);
 780 :         dimss__.push_back(dims__);
 781 :         dims__.resize(0);
 782 :         dims__.push_back(C);
 783 :         dimss__.push_back(dims__);
 784 :         dims__.resize(0);
 785 :         dims__.push_back(N);
 786 :         dimss__.push_back(dims__);
 787 :         dims__.resize(0);
 788 :         dims__.push_back(N);
 789 :         dimss__.push_back(dims__);
 790 :         dims__.resize(0);
 791 :         dims__.push_back(N);
 792 :         dimss__.push_back(dims__);
 793 :         dims__.resize(0);
 794 :         dims__.push_back(T_pred);
 795 :         dimss__.push_back(dims__);
 796 :         dims__.resize(0);
 797 :         dims__.push_back(T_pred);
 798 :         dimss__.push_back(dims__);
 799 :         dims__.resize(0);
 800 :         dims__.push_back(N_pred);
 801 :         dimss__.push_back(dims__);
 802 :         dims__.resize(0);
 803 :         dims__.push_back(N_pred);
 804 :         dimss__.push_back(dims__);
 805 :         dims__.resize(0);
 806 :         dims__.push_back(N_pred);
 807 :         dimss__.push_back(dims__);
 808 :         dims__.resize(0);
 809 :         dims__.push_back(N_pred);
 810 :         dimss__.push_back(dims__);
 811 :         dims__.resize(0);
 812 :         dims__.push_back(C);
 813 :         dimss__.push_back(dims__);
 814 :         dims__.resize(0);
 815 :         dims__.push_back((C - 1));
 816 :         dimss__.push_back(dims__);
 817 :         dims__.resize(0);
 818 :         dims__.push_back((C - 1));
 819 :         dimss__.push_back(dims__);
 820 :         dims__.resize(0);
 821 :         dims__.push_back((C - 1));
 822 :         dimss__.push_back(dims__);
 823 :     }
 824 : 
 825 :     template <typename RNG>
 826 :     void write_array(RNG& base_rng__,
 827 :                      std::vector<double>& params_r__,
 828 :                      std::vector<int>& params_i__,
 829 :                      std::vector<double>& vars__,
 830 :                      bool include_tparams__ = true,
 831 :                      bool include_gqs__ = true,
 832 :                      std::ostream* pstream__ = 0) const {
 833 :         vars__.resize(0);
 834 :         stan::io::reader<double> in__(params_r__,params_i__);
 835 :         static const char* function__ = "model23936388414e_mctd_foursurf_namespace::write_array";
 836 :         (void) function__; // dummy call to supress warning
 837 :         // read-transform, write parameters
 838 :         double loc_detect = in__.scalar_constrain();
 839 :         double scale_detect = in__.scalar_lb_constrain(0);
 840 :         vector_d loc_surface = in__.vector_constrain(C);
 841 :         vector_d scale_surface = in__.vector_lb_constrain(0,C);
 842 :         vector_d intercept = in__.vector_constrain(C);
 843 :         vector_d b_depth = in__.vector_constrain(C);
 844 :         vector_d b_tube = in__.vector_constrain(T);
 845 :         double sig_tube = in__.scalar_lb_constrain(0);
 846 :         vector_d sigma = in__.vector_lb_constrain(0,C);
 847 :         vars__.push_back(loc_detect);
 848 :         vars__.push_back(scale_detect);
 849 :         for (int k_0__ = 0; k_0__ < C; ++k_0__) {
 850 :             vars__.push_back(loc_surface[k_0__]);
 851 :         }
 852 :         for (int k_0__ = 0; k_0__ < C; ++k_0__) {
 853 :             vars__.push_back(scale_surface[k_0__]);
 854 :         }
 855 :         for (int k_0__ = 0; k_0__ < C; ++k_0__) {
 856 :             vars__.push_back(intercept[k_0__]);
 857 :         }
 858 :         for (int k_0__ = 0; k_0__ < C; ++k_0__) {
 859 :             vars__.push_back(b_depth[k_0__]);
 860 :         }
 861 :         for (int k_0__ = 0; k_0__ < T; ++k_0__) {
 862 :             vars__.push_back(b_tube[k_0__]);
 863 :         }
 864 :         vars__.push_back(sig_tube);
 865 :         for (int k_0__ = 0; k_0__ < C; ++k_0__) {
 866 :             vars__.push_back(sigma[k_0__]);
 867 :         }
 868 : 
 869 :         if (!include_tparams__) return;
 870 :         // declare and define transformed parameters
 871 :         double lp__ = 0.0;
 872 :         (void) lp__; // dummy call to supress warning
 873 :         stan::math::accumulator<double> lp_accum__;
 874 : 
 875 :         double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 876 :         (void) DUMMY_VAR__;  // suppress unused var warning
 877 : 
 878 :         vector_d mu(static_cast<Eigen::VectorXd::Index>(N));
 879 :         (void) mu;  // dummy to suppress unused var warning
 880 :         stan::math::initialize(mu, std::numeric_limits<double>::quiet_NaN());
 881 :         stan::math::fill(mu,DUMMY_VAR__);
 882 :         vector_d mu_obs(static_cast<Eigen::VectorXd::Index>(N));
 883 :         (void) mu_obs;  // dummy to suppress unused var warning
 884 :         stan::math::initialize(mu_obs, std::numeric_limits<double>::quiet_NaN());
 885 :         stan::math::fill(mu_obs,DUMMY_VAR__);
 886 :         vector_d detect_odds(static_cast<Eigen::VectorXd::Index>(N));
 887 :         (void) detect_odds;  // dummy to suppress unused var warning
 888 :         stan::math::initialize(detect_odds, std::numeric_limits<double>::quiet_NaN());
 889 :         stan::math::fill(detect_odds,DUMMY_VAR__);
 890 : 
 891 : 
 892 :         try {
 893 :             current_statement_begin__ = 116;
 894 :             stan::math::assign(mu, add(add(stan::model::rvalue(intercept, stan::model::cons_list(stan::model::index_multi(crop), stan::model::nil_index_list()), "intercept"),stan::model::rvalue(b_tube, stan::model::cons_list(stan::model::index_multi(tube), stan::model::nil_index_list()), "b_tube")),elt_multiply(stan::model::rvalue(b_depth, stan::model::cons_list(stan::model::index_multi(crop), stan::model::nil_index_list()), "b_depth"),log_depth_centered)));
 895 :             current_statement_begin__ = 119;
 896 :             stan::math::assign(mu_obs, add(mu,log_inv_logit(elt_divide(subtract(depth,stan::model::rvalue(loc_surface, stan::model::cons_list(stan::model::index_multi(crop), stan::model::nil_index_list()), "loc_surface")),stan::model::rvalue(scale_surface, stan::model::cons_list(stan::model::index_multi(crop), stan::model::nil_index_list()), "scale_surface")))));
 897 :             current_statement_begin__ = 122;
 898 :             stan::math::assign(detect_odds, divide(subtract(mu_obs,loc_detect),scale_detect));
 899 :         } catch (const std::exception& e) {
 900 :             stan::lang::rethrow_located(e,current_statement_begin__);
 901 :             // Next line prevents compiler griping about no return
 902 :             throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
 903 :         }
 904 : 
 905 :         // validate transformed parameters
 906 : 
 907 :         // write transformed parameters
 908 :         for (int k_0__ = 0; k_0__ < N; ++k_0__) {
 909 :             vars__.push_back(mu[k_0__]);
 910 :         }
 911 :         for (int k_0__ = 0; k_0__ < N; ++k_0__) {
 912 :             vars__.push_back(mu_obs[k_0__]);
 913 :         }
 914 :         for (int k_0__ = 0; k_0__ < N; ++k_0__) {
 915 :             vars__.push_back(detect_odds[k_0__]);
 916 :         }
 917 : 
 918 :         if (!include_gqs__) return;
 919 :         // declare and define generated quantities
 920 :         vector_d b_tube_pred(static_cast<Eigen::VectorXd::Index>(T_pred));
 921 :         (void) b_tube_pred;  // dummy to suppress unused var warning
 922 :         stan::math::initialize(b_tube_pred, std::numeric_limits<double>::quiet_NaN());
 923 :         stan::math::fill(b_tube_pred,DUMMY_VAR__);
 924 :         vector_d pred_tot(static_cast<Eigen::VectorXd::Index>(T_pred));
 925 :         (void) pred_tot;  // dummy to suppress unused var warning
 926 :         stan::math::initialize(pred_tot, std::numeric_limits<double>::quiet_NaN());
 927 :         stan::math::fill(pred_tot,DUMMY_VAR__);
 928 :         vector_d mu_pred(static_cast<Eigen::VectorXd::Index>(N_pred));
 929 :         (void) mu_pred;  // dummy to suppress unused var warning
 930 :         stan::math::initialize(mu_pred, std::numeric_limits<double>::quiet_NaN());
 931 :         stan::math::fill(mu_pred,DUMMY_VAR__);
 932 :         vector_d mu_obs_pred(static_cast<Eigen::VectorXd::Index>(N_pred));
 933 :         (void) mu_obs_pred;  // dummy to suppress unused var warning
 934 :         stan::math::initialize(mu_obs_pred, std::numeric_limits<double>::quiet_NaN());
 935 :         stan::math::fill(mu_obs_pred,DUMMY_VAR__);
 936 :         vector_d detect_odds_pred(static_cast<Eigen::VectorXd::Index>(N_pred));
 937 :         (void) detect_odds_pred;  // dummy to suppress unused var warning
 938 :         stan::math::initialize(detect_odds_pred, std::numeric_limits<double>::quiet_NaN());
 939 :         stan::math::fill(detect_odds_pred,DUMMY_VAR__);
 940 :         vector_d y_pred(static_cast<Eigen::VectorXd::Index>(N_pred));
 941 :         (void) y_pred;  // dummy to suppress unused var warning
 942 :         stan::math::initialize(y_pred, std::numeric_limits<double>::quiet_NaN());
 943 :         stan::math::fill(y_pred,DUMMY_VAR__);
 944 :         vector_d crop_tot(static_cast<Eigen::VectorXd::Index>(C));
 945 :         (void) crop_tot;  // dummy to suppress unused var warning
 946 :         stan::math::initialize(crop_tot, std::numeric_limits<double>::quiet_NaN());
 947 :         stan::math::fill(crop_tot,DUMMY_VAR__);
 948 :         vector<double> crop_tot_diff((C - 1), 0.0);
 949 :         stan::math::initialize(crop_tot_diff, std::numeric_limits<double>::quiet_NaN());
 950 :         stan::math::fill(crop_tot_diff,DUMMY_VAR__);
 951 :         vector<double> crop_int_diff((C - 1), 0.0);
 952 :         stan::math::initialize(crop_int_diff, std::numeric_limits<double>::quiet_NaN());
 953 :         stan::math::fill(crop_int_diff,DUMMY_VAR__);
 954 :         vector<double> crop_bdepth_diff((C - 1), 0.0);
 955 :         stan::math::initialize(crop_bdepth_diff, std::numeric_limits<double>::quiet_NaN());
 956 :         stan::math::fill(crop_bdepth_diff,DUMMY_VAR__);
 957 : 
 958 : 
 959 :         try {
 960 :             current_statement_begin__ = 158;
 961 :             for (int c = 1; c <= C; ++c) {
 962 : 
 963 :                 current_statement_begin__ = 159;
 964 :                 if (as_bool(logical_eq(get_base1(b_depth,c,"b_depth",1),-(1.0)))) {
 965 : 
 966 :                     current_statement_begin__ = 161;
 967 :                     stan::math::assign(get_base1_lhs(crop_tot,c,"crop_tot",1), (exp((get_base1(intercept,c,"intercept",1) - (get_base1(b_depth,c,"b_depth",1) * depth_logmean))) * log(depth_pred_max)));
 968 :                 } else {
 969 : 
 970 :                     current_statement_begin__ = 164;
 971 :                     stan::math::assign(get_base1_lhs(crop_tot,c,"crop_tot",1), ((exp((get_base1(intercept,c,"intercept",1) - (get_base1(b_depth,c,"b_depth",1) * depth_logmean))) * (pow(depth_pred_max,(get_base1(b_depth,c,"b_depth",1) + 1.0)) - 1.0)) / (get_base1(b_depth,c,"b_depth",1) + 1.0)));
 972 :                 }
 973 :             }
 974 :             current_statement_begin__ = 174;
 975 :             for (int c = 2; c <= C; ++c) {
 976 : 
 977 :                 current_statement_begin__ = 175;
 978 :                 stan::math::assign(get_base1_lhs(crop_tot_diff,(c - 1),"crop_tot_diff",1), (get_base1(crop_tot,c,"crop_tot",1) - get_base1(crop_tot,1,"crop_tot",1)));
 979 :                 current_statement_begin__ = 176;
 980 :                 stan::math::assign(get_base1_lhs(crop_int_diff,(c - 1),"crop_int_diff",1), (get_base1(intercept,c,"intercept",1) - get_base1(intercept,1,"intercept",1)));
 981 :                 current_statement_begin__ = 177;
 982 :                 stan::math::assign(get_base1_lhs(crop_bdepth_diff,(c - 1),"crop_bdepth_diff",1), (get_base1(b_depth,c,"b_depth",1) - get_base1(b_depth,1,"b_depth",1)));
 983 :             }
 984 :             current_statement_begin__ = 180;
 985 :             for (int t = 1; t <= T_pred; ++t) {
 986 : 
 987 :                 current_statement_begin__ = 182;
 988 :                 stan::math::assign(get_base1_lhs(b_tube_pred,t,"b_tube_pred",1), normal_rng(0,sig_tube, base_rng__));
 989 :             }
 990 :             current_statement_begin__ = 184;
 991 :             stan::math::assign(pred_tot, elt_multiply(stan::model::rvalue(crop_tot, stan::model::cons_list(stan::model::index_multi(tube_crop_pred), stan::model::nil_index_list()), "crop_tot"),exp(b_tube_pred)));
 992 :             current_statement_begin__ = 186;
 993 :             stan::math::assign(mu_pred, add(add(stan::model::rvalue(intercept, stan::model::cons_list(stan::model::index_multi(crop_pred), stan::model::nil_index_list()), "intercept"),stan::model::rvalue(b_tube_pred, stan::model::cons_list(stan::model::index_multi(tube_pred), stan::model::nil_index_list()), "b_tube_pred")),elt_multiply(stan::model::rvalue(b_depth, stan::model::cons_list(stan::model::index_multi(crop_pred), stan::model::nil_index_list()), "b_depth"),log_depth_pred_centered)));
 994 :             current_statement_begin__ = 189;
 995 :             stan::math::assign(mu_obs_pred, add(mu_pred,log_inv_logit(elt_divide(subtract(depth_pred,stan::model::rvalue(loc_surface, stan::model::cons_list(stan::model::index_multi(crop_pred), stan::model::nil_index_list()), "loc_surface")),stan::model::rvalue(scale_surface, stan::model::cons_list(stan::model::index_multi(crop_pred), stan::model::nil_index_list()), "scale_surface")))));
 996 :             current_statement_begin__ = 190;
 997 :             stan::math::assign(detect_odds_pred, inv_logit(divide(subtract(mu_obs_pred,loc_detect),scale_detect)));
 998 :             current_statement_begin__ = 191;
 999 :             for (int n = 1; n <= N_pred; ++n) {
1000 : 
1001 :                 current_statement_begin__ = 192;
1002 :                 stan::math::assign(get_base1_lhs(y_pred,n,"y_pred",1), (lognormal_rng(get_base1(mu_obs_pred,n,"mu_obs_pred",1),get_base1(sigma,get_base1(crop_pred,n,"crop_pred",1),"sigma",1), base_rng__) * bernoulli_rng(get_base1(detect_odds_pred,n,"detect_odds_pred",1), base_rng__)));
1003 :             }
1004 :         } catch (const std::exception& e) {
1005 :             stan::lang::rethrow_located(e,current_statement_begin__);
1006 :             // Next line prevents compiler griping about no return
1007 :             throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
1008 :         }
1009 : 
1010 :         // validate generated quantities
1011 :         check_greater_or_equal(function__,"pred_tot",pred_tot,0);
1012 :         check_greater_or_equal(function__,"y_pred",y_pred,0);
1013 :         check_greater_or_equal(function__,"crop_tot",crop_tot,0);
1014 : 
1015 :         // write generated quantities
1016 :         for (int k_0__ = 0; k_0__ < T_pred; ++k_0__) {
1017 :             vars__.push_back(b_tube_pred[k_0__]);
1018 :         }
1019 :         for (int k_0__ = 0; k_0__ < T_pred; ++k_0__) {
1020 :             vars__.push_back(pred_tot[k_0__]);
1021 :         }
1022 :         for (int k_0__ = 0; k_0__ < N_pred; ++k_0__) {
1023 :             vars__.push_back(mu_pred[k_0__]);
1024 :         }
1025 :         for (int k_0__ = 0; k_0__ < N_pred; ++k_0__) {
1026 :             vars__.push_back(mu_obs_pred[k_0__]);
1027 :         }
1028 :         for (int k_0__ = 0; k_0__ < N_pred; ++k_0__) {
1029 :             vars__.push_back(detect_odds_pred[k_0__]);
1030 :         }
1031 :         for (int k_0__ = 0; k_0__ < N_pred; ++k_0__) {
1032 :             vars__.push_back(y_pred[k_0__]);
1033 :         }
1034 :         for (int k_0__ = 0; k_0__ < C; ++k_0__) {
1035 :             vars__.push_back(crop_tot[k_0__]);
1036 :         }
1037 :         for (int k_0__ = 0; k_0__ < (C - 1); ++k_0__) {
1038 :             vars__.push_back(crop_tot_diff[k_0__]);
1039 :         }
1040 :         for (int k_0__ = 0; k_0__ < (C - 1); ++k_0__) {
1041 :             vars__.push_back(crop_int_diff[k_0__]);
1042 :         }
1043 :         for (int k_0__ = 0; k_0__ < (C - 1); ++k_0__) {
1044 :             vars__.push_back(crop_bdepth_diff[k_0__]);
1045 :         }
1046 : 
1047 :     }
1048 : 
1049 :     template <typename RNG>
1050 :     void write_array(RNG& base_rng,
1051 :                      Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
1052 :                      Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
1053 :                      bool include_tparams = true,
1054 :                      bool include_gqs = true,
1055 :                      std::ostream* pstream = 0) const {
1056 :       std::vector<double> params_r_vec(params_r.size());
1057 :       for (int i = 0; i < params_r.size(); ++i)
1058 :         params_r_vec[i] = params_r(i);
1059 :       std::vector<double> vars_vec;
1060 :       std::vector<int> params_i_vec;
1061 :       write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
1062 :       vars.resize(vars_vec.size());
1063 :       for (int i = 0; i < vars.size(); ++i)
1064 :         vars(i) = vars_vec[i];
1065 :     }
1066 : 
1067 :     static std::string model_name() {
1068 :         return "model23936388414e_mctd_foursurf";
1069 :     }
1070 : 
1071 : 
1072 :     void constrained_param_names(std::vector<std::string>& param_names__,
1073 :                                  bool include_tparams__ = true,
1074 :                                  bool include_gqs__ = true) const {
1075 :         std::stringstream param_name_stream__;
1076 :         param_name_stream__.str(std::string());
1077 :         param_name_stream__ << "loc_detect";
1078 :         param_names__.push_back(param_name_stream__.str());
1079 :         param_name_stream__.str(std::string());
1080 :         param_name_stream__ << "scale_detect";
1081 :         param_names__.push_back(param_name_stream__.str());
1082 :         for (int k_0__ = 1; k_0__ <= C; ++k_0__) {
1083 :             param_name_stream__.str(std::string());
1084 :             param_name_stream__ << "loc_surface" << '.' << k_0__;
1085 :             param_names__.push_back(param_name_stream__.str());
1086 :         }
1087 :         for (int k_0__ = 1; k_0__ <= C; ++k_0__) {
1088 :             param_name_stream__.str(std::string());
1089 :             param_name_stream__ << "scale_surface" << '.' << k_0__;
1090 :             param_names__.push_back(param_name_stream__.str());
1091 :         }
1092 :         for (int k_0__ = 1; k_0__ <= C; ++k_0__) {
1093 :             param_name_stream__.str(std::string());
1094 :             param_name_stream__ << "intercept" << '.' << k_0__;
1095 :             param_names__.push_back(param_name_stream__.str());
1096 :         }
1097 :         for (int k_0__ = 1; k_0__ <= C; ++k_0__) {
1098 :             param_name_stream__.str(std::string());
1099 :             param_name_stream__ << "b_depth" << '.' << k_0__;
1100 :             param_names__.push_back(param_name_stream__.str());
1101 :         }
1102 :         for (int k_0__ = 1; k_0__ <= T; ++k_0__) {
1103 :             param_name_stream__.str(std::string());
1104 :             param_name_stream__ << "b_tube" << '.' << k_0__;
1105 :             param_names__.push_back(param_name_stream__.str());
1106 :         }
1107 :         param_name_stream__.str(std::string());
1108 :         param_name_stream__ << "sig_tube";
1109 :         param_names__.push_back(param_name_stream__.str());
1110 :         for (int k_0__ = 1; k_0__ <= C; ++k_0__) {
1111 :             param_name_stream__.str(std::string());
1112 :             param_name_stream__ << "sigma" << '.' << k_0__;
1113 :             param_names__.push_back(param_name_stream__.str());
1114 :         }
1115 : 
1116 :         if (!include_gqs__ && !include_tparams__) return;
1117 :         for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
1118 :             param_name_stream__.str(std::string());
1119 :             param_name_stream__ << "mu" << '.' << k_0__;
1120 :             param_names__.push_back(param_name_stream__.str());
1121 :         }
1122 :         for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
1123 :             param_name_stream__.str(std::string());
1124 :             param_name_stream__ << "mu_obs" << '.' << k_0__;
1125 :             param_names__.push_back(param_name_stream__.str());
1126 :         }
1127 :         for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
1128 :             param_name_stream__.str(std::string());
1129 :             param_name_stream__ << "detect_odds" << '.' << k_0__;
1130 :             param_names__.push_back(param_name_stream__.str());
1131 :         }
1132 : 
1133 :         if (!include_gqs__) return;
1134 :         for (int k_0__ = 1; k_0__ <= T_pred; ++k_0__) {
1135 :             param_name_stream__.str(std::string());
1136 :             param_name_stream__ << "b_tube_pred" << '.' << k_0__;
1137 :             param_names__.push_back(param_name_stream__.str());
1138 :         }
1139 :         for (int k_0__ = 1; k_0__ <= T_pred; ++k_0__) {
1140 :             param_name_stream__.str(std::string());
1141 :             param_name_stream__ << "pred_tot" << '.' << k_0__;
1142 :             param_names__.push_back(param_name_stream__.str());
1143 :         }
1144 :         for (int k_0__ = 1; k_0__ <= N_pred; ++k_0__) {
1145 :             param_name_stream__.str(std::string());
1146 :             param_name_stream__ << "mu_pred" << '.' << k_0__;
1147 :             param_names__.push_back(param_name_stream__.str());
1148 :         }
1149 :         for (int k_0__ = 1; k_0__ <= N_pred; ++k_0__) {
1150 :             param_name_stream__.str(std::string());
1151 :             param_name_stream__ << "mu_obs_pred" << '.' << k_0__;
1152 :             param_names__.push_back(param_name_stream__.str());
1153 :         }
1154 :         for (int k_0__ = 1; k_0__ <= N_pred; ++k_0__) {
1155 :             param_name_stream__.str(std::string());
1156 :             param_name_stream__ << "detect_odds_pred" << '.' << k_0__;
1157 :             param_names__.push_back(param_name_stream__.str());
1158 :         }
1159 :         for (int k_0__ = 1; k_0__ <= N_pred; ++k_0__) {
1160 :             param_name_stream__.str(std::string());
1161 :             param_name_stream__ << "y_pred" << '.' << k_0__;
1162 :             param_names__.push_back(param_name_stream__.str());
1163 :         }
1164 :         for (int k_0__ = 1; k_0__ <= C; ++k_0__) {
1165 :             param_name_stream__.str(std::string());
1166 :             param_name_stream__ << "crop_tot" << '.' << k_0__;
1167 :             param_names__.push_back(param_name_stream__.str());
1168 :         }
1169 :         for (int k_0__ = 1; k_0__ <= (C - 1); ++k_0__) {
1170 :             param_name_stream__.str(std::string());
1171 :             param_name_stream__ << "crop_tot_diff" << '.' << k_0__;
1172 :             param_names__.push_back(param_name_stream__.str());
1173 :         }
1174 :         for (int k_0__ = 1; k_0__ <= (C - 1); ++k_0__) {
1175 :             param_name_stream__.str(std::string());
1176 :             param_name_stream__ << "crop_int_diff" << '.' << k_0__;
1177 :             param_names__.push_back(param_name_stream__.str());
1178 :         }
1179 :         for (int k_0__ = 1; k_0__ <= (C - 1); ++k_0__) {
1180 :             param_name_stream__.str(std::string());
1181 :             param_name_stream__ << "crop_bdepth_diff" << '.' << k_0__;
1182 :             param_names__.push_back(param_name_stream__.str());
1183 :         }
1184 :     }
1185 : 
1186 : 
1187 :     void unconstrained_param_names(std::vector<std::string>& param_names__,
1188 :                                    bool include_tparams__ = true,
1189 :                                    bool include_gqs__ = true) const {
1190 :         std::stringstream param_name_stream__;
1191 :         param_name_stream__.str(std::string());
1192 :         param_name_stream__ << "loc_detect";
1193 :         param_names__.push_back(param_name_stream__.str());
1194 :         param_name_stream__.str(std::string());
1195 :         param_name_stream__ << "scale_detect";
1196 :         param_names__.push_back(param_name_stream__.str());
1197 :         for (int k_0__ = 1; k_0__ <= C; ++k_0__) {
1198 :             param_name_stream__.str(std::string());
1199 :             param_name_stream__ << "loc_surface" << '.' << k_0__;
1200 :             param_names__.push_back(param_name_stream__.str());
1201 :         }
1202 :         for (int k_0__ = 1; k_0__ <= C; ++k_0__) {
1203 :             param_name_stream__.str(std::string());
1204 :             param_name_stream__ << "scale_surface" << '.' << k_0__;
1205 :             param_names__.push_back(param_name_stream__.str());
1206 :         }
1207 :         for (int k_0__ = 1; k_0__ <= C; ++k_0__) {
1208 :             param_name_stream__.str(std::string());
1209 :             param_name_stream__ << "intercept" << '.' << k_0__;
1210 :             param_names__.push_back(param_name_stream__.str());
1211 :         }
1212 :         for (int k_0__ = 1; k_0__ <= C; ++k_0__) {
1213 :             param_name_stream__.str(std::string());
1214 :             param_name_stream__ << "b_depth" << '.' << k_0__;
1215 :             param_names__.push_back(param_name_stream__.str());
1216 :         }
1217 :         for (int k_0__ = 1; k_0__ <= T; ++k_0__) {
1218 :             param_name_stream__.str(std::string());
1219 :             param_name_stream__ << "b_tube" << '.' << k_0__;
1220 :             param_names__.push_back(param_name_stream__.str());
1221 :         }
1222 :         param_name_stream__.str(std::string());
1223 :         param_name_stream__ << "sig_tube";
1224 :         param_names__.push_back(param_name_stream__.str());
1225 :         for (int k_0__ = 1; k_0__ <= C; ++k_0__) {
1226 :             param_name_stream__.str(std::string());
1227 :             param_name_stream__ << "sigma" << '.' << k_0__;
1228 :             param_names__.push_back(param_name_stream__.str());
1229 :         }
1230 : 
1231 :         if (!include_gqs__ && !include_tparams__) return;
1232 :         for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
1233 :             param_name_stream__.str(std::string());
1234 :             param_name_stream__ << "mu" << '.' << k_0__;
1235 :             param_names__.push_back(param_name_stream__.str());
1236 :         }
1237 :         for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
1238 :             param_name_stream__.str(std::string());
1239 :             param_name_stream__ << "mu_obs" << '.' << k_0__;
1240 :             param_names__.push_back(param_name_stream__.str());
1241 :         }
1242 :         for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
1243 :             param_name_stream__.str(std::string());
1244 :             param_name_stream__ << "detect_odds" << '.' << k_0__;
1245 :             param_names__.push_back(param_name_stream__.str());
1246 :         }
1247 : 
1248 :         if (!include_gqs__) return;
1249 :         for (int k_0__ = 1; k_0__ <= T_pred; ++k_0__) {
1250 :             param_name_stream__.str(std::string());
1251 :             param_name_stream__ << "b_tube_pred" << '.' << k_0__;
1252 :             param_names__.push_back(param_name_stream__.str());
1253 :         }
1254 :         for (int k_0__ = 1; k_0__ <= T_pred; ++k_0__) {
1255 :             param_name_stream__.str(std::string());
1256 :             param_name_stream__ << "pred_tot" << '.' << k_0__;
1257 :             param_names__.push_back(param_name_stream__.str());
1258 :         }
1259 :         for (int k_0__ = 1; k_0__ <= N_pred; ++k_0__) {
1260 :             param_name_stream__.str(std::string());
1261 :             param_name_stream__ << "mu_pred" << '.' << k_0__;
1262 :             param_names__.push_back(param_name_stream__.str());
1263 :         }
1264 :         for (int k_0__ = 1; k_0__ <= N_pred; ++k_0__) {
1265 :             param_name_stream__.str(std::string());
1266 :             param_name_stream__ << "mu_obs_pred" << '.' << k_0__;
1267 :             param_names__.push_back(param_name_stream__.str());
1268 :         }
1269 :         for (int k_0__ = 1; k_0__ <= N_pred; ++k_0__) {
1270 :             param_name_stream__.str(std::string());
1271 :             param_name_stream__ << "detect_odds_pred" << '.' << k_0__;
1272 :             param_names__.push_back(param_name_stream__.str());
1273 :         }
1274 :         for (int k_0__ = 1; k_0__ <= N_pred; ++k_0__) {
1275 :             param_name_stream__.str(std::string());
1276 :             param_name_stream__ << "y_pred" << '.' << k_0__;
1277 :             param_names__.push_back(param_name_stream__.str());
1278 :         }
1279 :         for (int k_0__ = 1; k_0__ <= C; ++k_0__) {
1280 :             param_name_stream__.str(std::string());
1281 :             param_name_stream__ << "crop_tot" << '.' << k_0__;
1282 :             param_names__.push_back(param_name_stream__.str());
1283 :         }
1284 :         for (int k_0__ = 1; k_0__ <= (C - 1); ++k_0__) {
1285 :             param_name_stream__.str(std::string());
1286 :             param_name_stream__ << "crop_tot_diff" << '.' << k_0__;
1287 :             param_names__.push_back(param_name_stream__.str());
1288 :         }
1289 :         for (int k_0__ = 1; k_0__ <= (C - 1); ++k_0__) {
1290 :             param_name_stream__.str(std::string());
1291 :             param_name_stream__ << "crop_int_diff" << '.' << k_0__;
1292 :             param_names__.push_back(param_name_stream__.str());
1293 :         }
1294 :         for (int k_0__ = 1; k_0__ <= (C - 1); ++k_0__) {
1295 :             param_name_stream__.str(std::string());
1296 :             param_name_stream__ << "crop_bdepth_diff" << '.' << k_0__;
1297 :             param_names__.push_back(param_name_stream__.str());
1298 :         }
1299 :     }
1300 : 
1301 : }; // model
1302 : 
1303 : } // namespace
1304 : 
1305 : typedef model23936388414e_mctd_foursurf_namespace::model23936388414e_mctd_foursurf stan_model;
1306 : 
1307 : #include <rstan/rstaninc.hpp>
1308 : /**
1309 :  * Define Rcpp Module to expose stan_fit's functions to R.
1310 :  */
1311 : RCPP_MODULE(stan_fit4model23936388414e_mctd_foursurf_mod){
1312 :   Rcpp::class_<rstan::stan_fit<model23936388414e_mctd_foursurf_namespace::model23936388414e_mctd_foursurf,
1313 :                boost::random::ecuyer1988> >("stan_fit4model23936388414e_mctd_foursurf")
1314 :     // .constructor<Rcpp::List>()
1315 :     .constructor<SEXP, SEXP>()
1316 :     // .constructor<SEXP, SEXP>()
1317 :     .method("call_sampler",
1318 :             &rstan::stan_fit<model23936388414e_mctd_foursurf_namespace::model23936388414e_mctd_foursurf, boost::random::ecuyer1988>::call_sampler)
1319 :     .method("param_names",
1320 :             &rstan::stan_fit<model23936388414e_mctd_foursurf_namespace::model23936388414e_mctd_foursurf, boost::random::ecuyer1988>::param_names)
1321 :     .method("param_names_oi",
1322 :             &rstan::stan_fit<model23936388414e_mctd_foursurf_namespace::model23936388414e_mctd_foursurf, boost::random::ecuyer1988>::param_names_oi)
1323 :     .method("param_fnames_oi",
1324 :             &rstan::stan_fit<model23936388414e_mctd_foursurf_namespace::model23936388414e_mctd_foursurf, boost::random::ecuyer1988>::param_fnames_oi)
1325 :     .method("param_dims",
1326 :             &rstan::stan_fit<model23936388414e_mctd_foursurf_namespace::model23936388414e_mctd_foursurf, boost::random::ecuyer1988>::param_dims)
1327 :     .method("param_dims_oi",
1328 :             &rstan::stan_fit<model23936388414e_mctd_foursurf_namespace::model23936388414e_mctd_foursurf, boost::random::ecuyer1988>::param_dims_oi)
1329 :     .method("update_param_oi",
1330 :             &rstan::stan_fit<model23936388414e_mctd_foursurf_namespace::model23936388414e_mctd_foursurf, boost::random::ecuyer1988>::update_param_oi)
1331 :     .method("param_oi_tidx",
1332 :             &rstan::stan_fit<model23936388414e_mctd_foursurf_namespace::model23936388414e_mctd_foursurf, boost::random::ecuyer1988>::param_oi_tidx)
1333 :     .method("grad_log_prob",
1334 :             &rstan::stan_fit<model23936388414e_mctd_foursurf_namespace::model23936388414e_mctd_foursurf, boost::random::ecuyer1988>::grad_log_prob)
1335 :     .method("log_prob",
1336 :             &rstan::stan_fit<model23936388414e_mctd_foursurf_namespace::model23936388414e_mctd_foursurf, boost::random::ecuyer1988>::log_prob)
1337 :     .method("unconstrain_pars",
1338 :             &rstan::stan_fit<model23936388414e_mctd_foursurf_namespace::model23936388414e_mctd_foursurf, boost::random::ecuyer1988>::unconstrain_pars)
1339 :     .method("constrain_pars",
1340 :             &rstan::stan_fit<model23936388414e_mctd_foursurf_namespace::model23936388414e_mctd_foursurf, boost::random::ecuyer1988>::constrain_pars)
1341 :     .method("num_pars_unconstrained",
1342 :             &rstan::stan_fit<model23936388414e_mctd_foursurf_namespace::model23936388414e_mctd_foursurf, boost::random::ecuyer1988>::num_pars_unconstrained)
1343 :     .method("unconstrained_param_names",
1344 :             &rstan::stan_fit<model23936388414e_mctd_foursurf_namespace::model23936388414e_mctd_foursurf, boost::random::ecuyer1988>::unconstrained_param_names)
1345 :     .method("constrained_param_names",
1346 :             &rstan::stan_fit<model23936388414e_mctd_foursurf_namespace::model23936388414e_mctd_foursurf, boost::random::ecuyer1988>::constrained_param_names)
1347 :     ;
1348 : }
1349 : 
1350 : // declarations
1351 : extern "C" {
1352 : SEXP file23936779aef( ) ;
1353 : }
1354 : 
1355 : // definition
1356 : 
1357 : SEXP file23936779aef(  ){
1358 :  return Rcpp::wrap("mctd_foursurf");
1359 : }
1360 : 
1361 : 
Compilation argument:
 /Library/Frameworks/R.framework/Resources/bin/R CMD SHLIB file23936779aef.cpp 2> file23936779aef.cpp.err.txt 
clang++ -ftemplate-depth-256 -I/Library/Frameworks/R.framework/Resources/include -DNDEBUG   -I"/Library/Frameworks/R.framework/Versions/3.3/Resources/library/Rcpp/include/"  -I"/Library/Frameworks/R.framework/Versions/3.3/Resources/library/RcppEigen/include/"  -I"/Library/Frameworks/R.framework/Versions/3.3/Resources/library/RcppEigen/include/unsupported"  -I"/Library/Frameworks/R.framework/Versions/3.3/Resources/library/rstan/include/boost_not_in_BH" -I"/Library/Frameworks/R.framework/Versions/3.3/Resources/library/BH/include" -I"/Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/src/"  -I"/Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/"  -I"/Library/Frameworks/R.framework/Versions/3.3/Resources/library/rstan/include" -DEIGEN_NO_DEBUG  -DBOOST_RESULT_OF_USE_TR1 -DBOOST_NO_DECLTYPE -DBOOST_DISABLE_ASSERTS -DBOOST_NO_CXX11_RVALUE_REFERENCES -I/usr/local/include -I/usr/local/include/freetype2 -I/opt/X11/include    -fPIC  -O3 -Wno-unused-variable -Wno-unused-function -Wno-unused-local-typedefs -march=native -c file23936779aef.cpp -o file23936779aef.o
clang++ -ftemplate-depth-256 -dynamiclib -Wl,-headerpad_max_install_names -undefined dynamic_lookup -single_module -multiply_defined suppress -L/Library/Frameworks/R.framework/Resources/lib -L/usr/local/lib -o file23936779aef.so file23936779aef.o -L/Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/lib -lStanHeaders -F/Library/Frameworks/R.framework/.. -framework R -Wl,-framework -Wl,CoreFoundation
In file included from file23936779aef.cpp:8:
In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/src/stan/model/model_header.hpp:4:
In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/stan/math.hpp:4:
In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/stan/math/rev/mat.hpp:4:
In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/stan/math/rev/core.hpp:12:
In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/stan/math/rev/core/gevv_vvv_vari.hpp:5:
In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/stan/math/rev/core/var.hpp:7:
In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/BH/include/boost/math/tools/config.hpp:13:
In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/BH/include/boost/config.hpp:39:
/Library/Frameworks/R.framework/Versions/3.3/Resources/library/BH/include/boost/config/compiler/clang.hpp:196:11: warning: 'BOOST_NO_CXX11_RVALUE_REFERENCES' macro redefined [-Wmacro-redefined]
#  define BOOST_NO_CXX11_RVALUE_REFERENCES
          ^
<command line>:6:9: note: previous definition is here
#define BOOST_NO_CXX11_RVALUE_REFERENCES 1
        ^
1 warning generated.

CHECKING DATA AND PREPROCESSING FOR MODEL 'mctd_foursurf' NOW.

COMPILING MODEL 'mctd_foursurf' NOW.

STARTING SAMPLER FOR MODEL 'mctd_foursurf' NOW.

CHECKING DATA AND PREPROCESSING FOR MODEL 'mctd_foursurf' NOW.

COMPILING MODEL 'mctd_foursurf' NOW.

STARTING SAMPLER FOR MODEL 'mctd_foursurf' NOW.

SAMPLING FOR MODEL 'mctd_foursurf' NOW (CHAIN 1).

Chain 1, Iteration:    1 / 5000 [  0%]  (Warmup)
CHECKING DATA AND PREPROCESSING FOR MODEL 'mctd_foursurf' NOW.

COMPILING MODEL 'mctd_foursurf' NOW.

STARTING SAMPLER FOR MODEL 'mctd_foursurf' NOW.

SAMPLING FOR MODEL 'mctd_foursurf' NOW (CHAIN 2).

Chain 2, Iteration:    1 / 5000 [  0%]  (Warmup)
CHECKING DATA AND PREPROCESSING FOR MODEL 'mctd_foursurf' NOW.

COMPILING MODEL 'mctd_foursurf' NOW.

STARTING SAMPLER FOR MODEL 'mctd_foursurf' NOW.

SAMPLING FOR MODEL 'mctd_foursurf' NOW (CHAIN 3).

Chain 3, Iteration:    1 / 5000 [  0%]  (Warmup)
CHECKING DATA AND PREPROCESSING FOR MODEL 'mctd_foursurf' NOW.

COMPILING MODEL 'mctd_foursurf' NOW.

STARTING SAMPLER FOR MODEL 'mctd_foursurf' NOW.

SAMPLING FOR MODEL 'mctd_foursurf' NOW (CHAIN 4).

Chain 4, Iteration:    1 / 5000 [  0%]  (Warmup)
CHECKING DATA AND PREPROCESSING FOR MODEL 'mctd_foursurf' NOW.

COMPILING MODEL 'mctd_foursurf' NOW.

STARTING SAMPLER FOR MODEL 'mctd_foursurf' NOW.

SAMPLING FOR MODEL 'mctd_foursurf' NOW (CHAIN 5).

Chain 5, Iteration:    1 / 5000 [  0%]  (Warmup)
Chain 1, Iteration:  500 / 5000 [ 10%]  (Warmup)
Chain 2, Iteration:  500 / 5000 [ 10%]  (Warmup)
Chain 4, Iteration:  500 / 5000 [ 10%]  (Warmup)
Chain 3, Iteration:  500 / 5000 [ 10%]  (Warmup)
Chain 5, Iteration:  500 / 5000 [ 10%]  (Warmup)
Chain 1, Iteration: 1000 / 5000 [ 20%]  (Warmup)
Chain 1, Iteration: 1001 / 5000 [ 20%]  (Sampling)
Chain 4, Iteration: 1000 / 5000 [ 20%]  (Warmup)
Chain 4, Iteration: 1001 / 5000 [ 20%]  (Sampling)
Chain 5, Iteration: 1000 / 5000 [ 20%]  (Warmup)
Chain 5, Iteration: 1001 / 5000 [ 20%]  (Sampling)
Chain 3, Iteration: 1000 / 5000 [ 20%]  (Warmup)
Chain 3, Iteration: 1001 / 5000 [ 20%]  (Sampling)
Chain 2, Iteration: 1000 / 5000 [ 20%]  (Warmup)
Chain 2, Iteration: 1001 / 5000 [ 20%]  (Sampling)
Chain 1, Iteration: 1500 / 5000 [ 30%]  (Sampling)
Chain 4, Iteration: 1500 / 5000 [ 30%]  (Sampling)
Chain 3, Iteration: 1500 / 5000 [ 30%]  (Sampling)
Chain 5, Iteration: 1500 / 5000 [ 30%]  (Sampling)
Chain 2, Iteration: 1500 / 5000 [ 30%]  (Sampling)
Chain 1, Iteration: 2000 / 5000 [ 40%]  (Sampling)
Chain 3, Iteration: 2000 / 5000 [ 40%]  (Sampling)
Chain 4, Iteration: 2000 / 5000 [ 40%]  (Sampling)
Chain 2, Iteration: 2000 / 5000 [ 40%]  (Sampling)
Chain 5, Iteration: 2000 / 5000 [ 40%]  (Sampling)
Chain 1, Iteration: 2500 / 5000 [ 50%]  (Sampling)
Chain 3, Iteration: 2500 / 5000 [ 50%]  (Sampling)
Chain 4, Iteration: 2500 / 5000 [ 50%]  (Sampling)
Chain 2, Iteration: 2500 / 5000 [ 50%]  (Sampling)
Chain 5, Iteration: 2500 / 5000 [ 50%]  (Sampling)
Chain 1, Iteration: 3000 / 5000 [ 60%]  (Sampling)
Chain 3, Iteration: 3000 / 5000 [ 60%]  (Sampling)
Chain 4, Iteration: 3000 / 5000 [ 60%]  (Sampling)
Chain 2, Iteration: 3000 / 5000 [ 60%]  (Sampling)
Chain 5, Iteration: 3000 / 5000 [ 60%]  (Sampling)
Chain 1, Iteration: 3500 / 5000 [ 70%]  (Sampling)
Chain 3, Iteration: 3500 / 5000 [ 70%]  (Sampling)
Chain 4, Iteration: 3500 / 5000 [ 70%]  (Sampling)
Chain 2, Iteration: 3500 / 5000 [ 70%]  (Sampling)
Chain 5, Iteration: 3500 / 5000 [ 70%]  (Sampling)
Chain 1, Iteration: 4000 / 5000 [ 80%]  (Sampling)
Chain 3, Iteration: 4000 / 5000 [ 80%]  (Sampling)
Chain 2, Iteration: 4000 / 5000 [ 80%]  (Sampling)
Chain 4, Iteration: 4000 / 5000 [ 80%]  (Sampling)
Chain 1, Iteration: 4500 / 5000 [ 90%]  (Sampling)
Chain 5, Iteration: 4000 / 5000 [ 80%]  (Sampling)
Chain 3, Iteration: 4500 / 5000 [ 90%]  (Sampling)
Chain 2, Iteration: 4500 / 5000 [ 90%]  (Sampling)
Chain 4, Iteration: 4500 / 5000 [ 90%]  (Sampling)
Chain 1, Iteration: 5000 / 5000 [100%]  (Sampling)
 Elapsed Time: 31.5303 seconds (Warm-up)
               108.375 seconds (Sampling)
               139.905 seconds (Total)

The following numerical problems occured the indicated number of times on chain 1
                                                                                            count
Exception thrown at line 139: lognormal_log: Scale parameter[1] is inf, but must be finite!     7
Exception thrown at line 128: normal_log: Scale parameter is 0, but must be > 0!                1
When a numerical problem occurs, the Hamiltonian proposal gets rejected.
See http://mc-stan.org/misc/warnings.html#exception-hamiltonian-proposal-rejected
If the number in the 'count' column is small, do not ask about this message on stan-users.

Chain 3, Iteration: 5000 / 5000 [100%]  (Sampling)
 Elapsed Time: 32.3338 seconds (Warm-up)
               107.011 seconds (Sampling)
               139.345 seconds (Total)

The following numerical problems occured the indicated number of times on chain 3
                                                                                             count
Exception thrown at line 139: lognormal_log: Scale parameter[1] is inf, but must be finite!      7
Exception thrown at line 139: lognormal_log: Scale parameter[12] is inf, but must be finite!     1
When a numerical problem occurs, the Hamiltonian proposal gets rejected.
See http://mc-stan.org/misc/warnings.html#exception-hamiltonian-proposal-rejected
If the number in the 'count' column is small, do not ask about this message on stan-users.

Chain 5, Iteration: 4500 / 5000 [ 90%]  (Sampling)
Chain 2, Iteration: 5000 / 5000 [100%]  (Sampling)
 Elapsed Time: 34.5444 seconds (Warm-up)
               107.091 seconds (Sampling)
               141.636 seconds (Total)

The following numerical problems occured the indicated number of times on chain 2
                                                                                            count
Exception thrown at line 139: lognormal_log: Scale parameter[1] is inf, but must be finite!    10
When a numerical problem occurs, the Hamiltonian proposal gets rejected.
See http://mc-stan.org/misc/warnings.html#exception-hamiltonian-proposal-rejected
If the number in the 'count' column is small, do not ask about this message on stan-users.

Chain 4, Iteration: 5000 / 5000 [100%]  (Sampling)
 Elapsed Time: 31.5021 seconds (Warm-up)
               109.987 seconds (Sampling)
               141.489 seconds (Total)

The following numerical problems occured the indicated number of times on chain 4
                                                                                            count
Exception thrown at line 139: lognormal_log: Scale parameter[1] is inf, but must be finite!     6
Exception thrown at line 128: normal_log: Scale parameter is 0, but must be > 0!                1
Exception thrown at line 139: lognormal_log: Scale parameter[2] is inf, but must be finite!     1
When a numerical problem occurs, the Hamiltonian proposal gets rejected.
See http://mc-stan.org/misc/warnings.html#exception-hamiltonian-proposal-rejected
If the number in the 'count' column is small, do not ask about this message on stan-users.

Chain 5, Iteration: 5000 / 5000 [100%]  (Sampling)
 Elapsed Time: 31.2849 seconds (Warm-up)
               120.463 seconds (Sampling)
               151.748 seconds (Total)

The following numerical problems occured the indicated number of times on chain 5
                                                                                             count
Exception thrown at line 139: lognormal_log: Scale parameter[1] is inf, but must be finite!      4
Exception thrown at line 139: lognormal_log: Scale parameter[12] is inf, but must be finite!     3
When a numerical problem occurs, the Hamiltonian proposal gets rejected.
See http://mc-stan.org/misc/warnings.html#exception-hamiltonian-proposal-rejected
If the number in the 'count' column is small, do not ask about this message on stan-users.
Warning messages:
1: There were 6 divergent transitions after warmup. Increasing adapt_delta above 0.99 may help. See
http://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup 
2: Examine the pairs() plot to diagnose sampling problems
 
Warning messages:
1: There were 6 divergent transitions after warmup. Increasing adapt_delta above 0.99 may help. See
http://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup
2: Examine the pairs() plot to diagnose sampling problems

Inference for Stan model: mctd_foursurf.
5 chains, each with iter=5000; warmup=1000; thin=1; 
post-warmup draws per chain=4000, total post-warmup draws=20000.

                        mean se_mean    sd     2.5%      25%      50%      75%
loc_detect             -8.00    0.00  0.12    -8.23    -8.08    -8.00    -7.93
scale_detect            0.67    0.00  0.12     0.45     0.58     0.66     0.74
loc_surface[1]         11.97    0.06  6.94    -3.13     7.63    12.55    16.81
loc_surface[2]         15.34    0.03  2.97     9.30    13.43    15.39    17.31
loc_surface[3]         14.63    0.04  4.58     5.83    11.61    14.69    17.66
loc_surface[4]         13.31    0.03  2.87     7.93    11.34    13.23    15.19
scale_surface[1]        7.75    0.04  4.79     1.95     4.74     6.47     9.31
scale_surface[2]        4.69    0.01  1.08     3.07     3.96     4.54     5.25
scale_surface[3]        5.59    0.02  2.14     2.43     4.25     5.26     6.53
scale_surface[4]        3.62    0.01  0.89     2.08     3.01     3.55     4.15
intercept[1]           -9.60    0.01  0.39   -10.42    -9.86    -9.58    -9.33
intercept[2]           -7.52    0.00  0.17    -7.84    -7.63    -7.52    -7.41
intercept[3]           -8.46    0.00  0.22    -8.91    -8.60    -8.45    -8.31
intercept[4]           -7.87    0.00  0.16    -8.18    -7.98    -7.87    -7.77
b_depth[1]             -1.04    0.00  0.35    -1.86    -1.24    -0.98    -0.78
b_depth[2]             -0.86    0.00  0.20    -1.28    -0.99    -0.85    -0.72
b_depth[3]             -0.97    0.00  0.26    -1.53    -1.13    -0.95    -0.78
b_depth[4]             -0.98    0.00  0.21    -1.42    -1.10    -0.96    -0.83
sig_tube                0.48    0.00  0.10     0.31     0.42     0.48     0.54
sigma[1]                2.48    0.00  0.35     1.90     2.23     2.44     2.68
sigma[2]                2.46    0.00  0.12     2.23     2.38     2.46     2.54
sigma[3]                2.37    0.00  0.17     2.06     2.25     2.36     2.48
sigma[4]                2.32    0.00  0.11     2.12     2.25     2.32     2.39
crop_tot[1]             0.03    0.00  0.10     0.01     0.01     0.02     0.03
crop_tot[2]             0.13    0.00  0.05     0.07     0.10     0.12     0.15
crop_tot[3]             0.06    0.00  0.04     0.03     0.04     0.05     0.07
crop_tot[4]             0.11    0.00  0.05     0.06     0.08     0.10     0.12
crop_tot_diff[1]        0.10    0.00  0.11     0.02     0.07     0.09     0.12
crop_tot_diff[2]        0.04    0.00  0.10    -0.04     0.02     0.03     0.05
crop_tot_diff[3]        0.08    0.00  0.11     0.00     0.05     0.07     0.10
crop_int_diff[1]        2.08    0.01  0.44     1.31     1.77     2.05     2.36
crop_int_diff[2]        1.15    0.00  0.34     0.54     0.91     1.12     1.36
crop_int_diff[3]        1.73    0.01  0.38     1.05     1.46     1.71     1.98
crop_bdepth_diff[1]     0.18    0.00  0.38    -0.46    -0.09     0.14     0.40
crop_bdepth_diff[2]     0.07    0.00  0.40    -0.65    -0.20     0.05     0.32
crop_bdepth_diff[3]     0.06    0.00  0.36    -0.57    -0.19     0.03     0.28
lp__                -1501.80    0.46 14.30 -1529.94 -1511.38 -1501.81 -1492.04
                       97.5% n_eff Rhat
loc_detect             -7.78  6751    1
scale_detect            0.92  1483    1
loc_surface[1]         23.99 12322    1
loc_surface[2]         21.07 11395    1
loc_surface[3]         23.41 12618    1
loc_surface[4]         19.14  9599    1
scale_surface[1]       21.04 14700    1
scale_surface[2]        7.20 20000    1
scale_surface[3]       10.66 12373    1
scale_surface[4]        5.58 20000    1
intercept[1]           -8.89  2672    1
intercept[2]           -7.18  9110    1
intercept[3]           -8.05  3585    1
intercept[4]           -7.57  8207    1
b_depth[1]             -0.50  5982    1
b_depth[2]             -0.49  7044    1
b_depth[3]             -0.51  7285    1
b_depth[4]             -0.61  4149    1
sig_tube                0.69  1544    1
sigma[1]                3.26 20000    1
sigma[2]                2.72 20000    1
sigma[3]                2.73 20000    1
sigma[4]                2.55 20000    1
crop_tot[1]             0.10 17027    1
crop_tot[2]             0.26  7856    1
crop_tot[3]             0.16 11052    1
crop_tot[4]             0.24  6614    1
crop_tot_diff[1]        0.24 14467    1
crop_tot_diff[2]        0.14 15508    1
crop_tot_diff[3]        0.22 13737    1
crop_int_diff[1]        3.00  2788    1
crop_int_diff[2]        1.87  4715    1
crop_int_diff[3]        2.54  2417    1
crop_bdepth_diff[1]     1.02 11072    1
crop_bdepth_diff[2]     0.92 11804    1
crop_bdepth_diff[3]     0.87 12302    1
lp__                -1473.75   987    1

Samples were drawn using NUTS(diag_e) at Thu Jan 12 16:51:39 2017.
For each parameter, n_eff is a crude measure of effective sample size,
and Rhat is the potential scale reduction factor on split chains (at 
convergence, Rhat=1).
Inference for Stan model: mctd_foursurf.
5 chains, each with iter=5000; warmup=1000; thin=1; 
post-warmup draws per chain=4000, total post-warmup draws=20000.

                      mean se_mean   sd   2.5%   25%   50%   75% 97.5% n_eff
y_pred[1]             0.01    0.00 0.15   0.00  0.00  0.00  0.00  0.07 20000
y_pred[15]            0.01    0.00 0.10   0.00  0.00  0.00  0.00  0.07 19884
y_pred[28]            0.00    0.00 0.37   0.00  0.00  0.00  0.00  0.00 20000
mu_pred[1]           -4.10    0.01 0.97  -5.89 -4.77 -4.14 -3.47 -2.07  8170
mu_pred[15]          -6.95    0.00 0.55  -7.99 -7.32 -6.97 -6.60 -5.84 15215
mu_pred[28]          -9.35    0.01 0.61 -10.63 -9.73 -9.32 -8.93 -8.24  6290
mu_obs_pred[1]       -7.32    0.00 0.63  -8.60 -7.73 -7.33 -6.91 -6.07 19223
mu_obs_pred[15]      -7.10    0.00 0.53  -8.12 -7.46 -7.11 -6.76 -6.02 18336
mu_obs_pred[28]      -9.39    0.01 0.61 -10.67 -9.77 -9.35 -8.97 -8.28  6222
detect_odds_pred[1]   0.71    0.00 0.17   0.30  0.60  0.74  0.84  0.95 20000
detect_odds_pred[15]  0.77    0.00 0.13   0.46  0.70  0.80  0.87  0.95 19046
detect_odds_pred[28]  0.14    0.00 0.09   0.02  0.07  0.11  0.18  0.38 18020
pred_tot[1]           0.15    0.00 0.11   0.04  0.08  0.12  0.17  0.42 11757
                     Rhat
y_pred[1]               1
y_pred[15]              1
y_pred[28]              1
mu_pred[1]              1
mu_pred[15]             1
mu_pred[28]             1
mu_obs_pred[1]          1
mu_obs_pred[15]         1
mu_obs_pred[28]         1
detect_odds_pred[1]     1
detect_odds_pred[15]    1
detect_odds_pred[28]    1
pred_tot[1]             1

Samples were drawn using NUTS(diag_e) at Thu Jan 12 16:51:39 2017.
For each parameter, n_eff is a crude measure of effective sample size,
and Rhat is the potential scale reduction factor on split chains (at 
convergence, Rhat=1).
[1] "mean of depth: 53.7776934749621"

mean of log(nonzero root volume): -7.669138 

RMSE of mu_obs vs log observed (zeroes excluded):  2.353977 
RMSE/var:  0.388183 

ci_level: 0.8 (80% intervals)
outer_level: 0.95 (95% intervals)
ci_level: 0.8 (80% intervals)
outer_level: 0.95 (95% intervals)
ci_level: 0.8 (80% intervals)
outer_level: 0.95 (95% intervals)
ci_level: 0.8 (80% intervals)
outer_level: 0.95 (95% intervals)
ci_level: 0.8 (80% intervals)
outer_level: 0.95 (95% intervals)
ci_level: 0.8 (80% intervals)
outer_level: 0.95 (95% intervals)
ci_level: 0.8 (80% intervals)
outer_level: 0.95 (95% intervals)
Warning message:
Removed 719 rows containing non-finite values (stat_smooth). 
null device 
          1 

real	4m13.085s
user	13m22.127s
sys	0m7.712s
Extracting fits
Loading required package: ggplot2
Loading required package: StanHeaders
rstan (Version 2.14.1, packaged: 2016-12-28 14:55:41 UTC, GitRev: 5fa1e80eb817)
For execution on a local, multicore CPU with excess RAM we recommend calling
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())

Attaching package: dplyr

The following objects are masked from package:stats:

    filter, lag

The following objects are masked from package:base:

    intersect, setdiff, setequal, union

Joining, by = c("term", "estimate", "std.error", "rhat", "ess")
Joining, by = "crop_num"
Joining, by = "parameter"
