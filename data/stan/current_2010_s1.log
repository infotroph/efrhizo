Starting current_2010_s1 on  Sat Nov 19 14:16:06 UTC 2016
Running mctd_foursurf.R for year  2010  session  1
Loading required package: ggplot2
Loading required package: StanHeaders
rstan (Version 2.12.1, packaged: , GitRev: 85f7a56811da)
For execution on a local, multicore CPU with excess RAM we recommend calling
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
R version 3.3.2 (2016-10-31)
Platform: x86_64-apple-darwin13.4.0 (64-bit)
Running under: OS X El Capitan 10.11.6

locale:
[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8

attached base packages:
[1] stats     graphics  grDevices utils     datasets  base     

other attached packages:
[1] rstan_2.12.1       StanHeaders_2.12.0 ggplot2_2.2.0     

loaded via a namespace (and not attached):
 [1] colorspace_1.3-0 scales_0.4.1     assertthat_0.1   lazyeval_0.2.0  
 [5] plyr_1.8.4       tools_3.3.2      inline_0.3.14    gtable_0.2.0    
 [9] tibble_1.2       gridExtra_2.2.1  Rcpp_0.12.7      grid_3.3.2      
[13] methods_3.3.2    stats4_3.3.2     munsell_0.4.3   
structure(list(Tube = c(9L, 10L, 11L, 12L, 13L, 14L, 15L, 16L, 
17L, 18L, 19L, 20L, 33L, 34L, 35L, 36L, 37L, 38L, 39L, 40L, 41L, 
42L, 43L, 44L, 45L, 46L, 47L, 48L, 49L, 51L, 52L, 53L, 54L, 55L, 
56L, 57L, 58L, 59L, 60L, 62L, 63L, 64L, 65L, 66L, 67L, 69L, 70L, 
71L, 72L, 73L, 74L, 75L, 76L, 77L, 78L, 79L, 80L, 81L, 82L, 83L, 
84L, 85L, 86L, 87L, 88L, 89L, 90L, 91L, 92L, 93L, 94L, 95L, 96L
), Tube_alias = 1:73), .Names = c("Tube", "Tube_alias"), row.names = c(NA, 
-73L), class = "data.frame")
   Tube Tube_alias
1     9          1
2    10          2
3    11          3
4    12          4
5    13          5
6    14          6
7    15          7
8    16          8
9    17          9
10   18         10
11   19         11
12   20         12
13   33         13
14   34         14
15   35         15
16   36         16
17   37         17
18   38         18
19   39         19
20   40         20
21   41         21
22   42         22
23   43         23
24   44         24
25   45         25
26   46         26
27   47         27
28   48         28
29   49         29
30   51         30
31   52         31
32   53         32
33   54         33
34   55         34
35   56         35
36   57         36
37   58         37
38   59         38
39   60         39
40   62         40
41   63         41
42   64         42
43   65         43
44   66         44
45   67         45
46   69         46
47   70         47
48   71         48
49   72         49
50   73         50
51   74         51
52   75         52
53   76         53
54   77         54
55   78         55
56   79         56
57   80         57
58   81         58
59   82         59
60   83         60
61   84         61
62   85         62
63   86         63
64   87         64
65   88         65
66   89         66
67   90         67
68   91         68
69   92         69
70   93         70
71   94         71
72   95         72
73   96         73
[1] "Using data from 2010 , session 1"
[1] "Crop name-to-number key:"
              num          name first_tube last_tube first_tube_alias
Maize-Soybean   1 Maize-Soybean          9        20                1
Switchgrass     2   Switchgrass         49        72               29
Miscanthus      3    Miscanthus         33        48               13
Prairie         4       Prairie         73        96               50
              last_tube_alias n_tubes
Maize-Soybean              12      12
Switchgrass                49      21
Miscanthus                 28      16
Prairie                    73      24
[1] "conditions for predicted data:"
   tube depth       Species
1     1     1   Switchgrass
2     2     1    Miscanthus
3     3     1       Prairie
4     4     1 Maize-Soybean
5     1     8   Switchgrass
6     2     8    Miscanthus
7     3     8       Prairie
8     4     8 Maize-Soybean
9     1    15   Switchgrass
10    2    15    Miscanthus
11    3    15       Prairie
12    4    15 Maize-Soybean
13    1    21   Switchgrass
14    2    21    Miscanthus
15    3    21       Prairie
16    4    21 Maize-Soybean
17    1    28   Switchgrass
18    2    28    Miscanthus
19    3    28       Prairie
20    4    28 Maize-Soybean
21    1    35   Switchgrass
22    2    35    Miscanthus
23    3    35       Prairie
24    4    35 Maize-Soybean
25    1    42   Switchgrass
26    2    42    Miscanthus
27    3    42       Prairie
28    4    42 Maize-Soybean
29    1    49   Switchgrass
30    2    49    Miscanthus
31    3    49       Prairie
32    4    49 Maize-Soybean
33    1    55   Switchgrass
34    2    55    Miscanthus
35    3    55       Prairie
36    4    55 Maize-Soybean
37    1    62   Switchgrass
38    2    62    Miscanthus
39    3    62       Prairie
40    4    62 Maize-Soybean
41    1    69   Switchgrass
42    2    69    Miscanthus
43    3    69       Prairie
44    4    69 Maize-Soybean
45    1    76   Switchgrass
46    2    76    Miscanthus
47    3    76       Prairie
48    4    76 Maize-Soybean
49    1    82   Switchgrass
50    2    82    Miscanthus
51    3    82       Prairie
52    4    82 Maize-Soybean
53    1    89   Switchgrass
54    2    89    Miscanthus
55    3    89       Prairie
56    4    89 Maize-Soybean
57    1    96   Switchgrass
58    2    96    Miscanthus
59    3    96       Prairie
60    4    96 Maize-Soybean
61    1   103   Switchgrass
62    2   103    Miscanthus
63    3   103       Prairie
64    4   103 Maize-Soybean
65    1   110   Switchgrass
66    2   110    Miscanthus
67    3   110       Prairie
68    4   110 Maize-Soybean
69    1   116   Switchgrass
70    2   116    Miscanthus
71    3   116       Prairie
72    4   116 Maize-Soybean
73    1   123   Switchgrass
74    2   123    Miscanthus
75    3   123       Prairie
76    4   123 Maize-Soybean
77    1   130   Switchgrass
78    2   130    Miscanthus
79    3   130       Prairie
80    4   130 Maize-Soybean

TRANSLATING MODEL 'mctd_foursurf' FROM Stan CODE TO C++ CODE NOW.
successful in parsing the Stan model 'mctd_foursurf'.
hash mismatch so recompiling; make sure Stan code ends with a blank line
OS: x86_64, darwin13.4.0; rstan: 2.12.1; Rcpp: 0.12.7; inline: 0.3.14 
 >> setting environment variables: 
PKG_LIBS =  -L'/Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/lib' -lStanHeaders
PKG_CPPFLAGS =   -I"/Library/Frameworks/R.framework/Versions/3.3/Resources/library/Rcpp/include/"  -I"/Library/Frameworks/R.framework/Versions/3.3/Resources/library/RcppEigen/include/"  -I"/Library/Frameworks/R.framework/Versions/3.3/Resources/library/RcppEigen/include/unsupported"  -I"/Library/Frameworks/R.framework/Versions/3.3/Resources/library/rstan/include/boost_not_in_BH" -I"/Library/Frameworks/R.framework/Versions/3.3/Resources/library/BH/include" -I"/Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/src/"  -I"/Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/"  -I"/Library/Frameworks/R.framework/Versions/3.3/Resources/library/rstan/include" -DEIGEN_NO_DEBUG  -DBOOST_RESULT_OF_USE_TR1 -DBOOST_NO_DECLTYPE -DBOOST_DISABLE_ASSERTS
 >> Program source :

   1 : 
   2 : // includes from the plugin
   3 : 
   4 : 
   5 : // user includes
   6 : #define STAN__SERVICES__COMMAND_HPP// Code generated by Stan version 2.12
   7 : 
   8 : #include <stan/model/model_header.hpp>
   9 : 
  10 : namespace model7e2b110f6d81_mctd_foursurf_namespace {
  11 : 
  12 : using std::istream;
  13 : using std::string;
  14 : using std::stringstream;
  15 : using std::vector;
  16 : using stan::io::dump;
  17 : using stan::math::lgamma;
  18 : using stan::model::prob_grad;
  19 : using namespace stan::math;
  20 : 
  21 : typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
  22 : typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
  23 : typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;
  24 : 
  25 : static int current_statement_begin__;
  26 : 
  27 : class model7e2b110f6d81_mctd_foursurf : public prob_grad {
  28 : private:
  29 :     int N;
  30 :     int T;
  31 :     int C;
  32 :     vector<int> tube;
  33 :     vector<int> crop;
  34 :     vector<double> depth;
  35 :     vector_d y;
  36 :     int N_pred;
  37 :     int T_pred;
  38 :     int C_pred;
  39 :     vector<int> crop_pred;
  40 :     vector<int> tube_pred;
  41 :     vector<double> depth_pred;
  42 :     double sig_tube_prior_m;
  43 :     double sig_tube_prior_s;
  44 :     double sigma_prior_m;
  45 :     double sigma_prior_s;
  46 :     double intercept_prior_m;
  47 :     double intercept_prior_s;
  48 :     double b_depth_prior_m;
  49 :     double b_depth_prior_s;
  50 :     double loc_surface_prior_m;
  51 :     double loc_surface_prior_s;
  52 :     double scale_surface_prior_m;
  53 :     double scale_surface_prior_s;
  54 :     double loc_detect_prior_m;
  55 :     double loc_detect_prior_s;
  56 :     double scale_detect_prior_m;
  57 :     double scale_detect_prior_s;
  58 :     double depth_logmean;
  59 :     double depth_pred_max;
  60 :     vector<int> tube_crop_pred;
  61 :     vector<double> log_depth_centered;
  62 :     vector<double> log_depth_pred_centered;
  63 :     vector<int> y_logi;
  64 :     int n_pos;
  65 : public:
  66 :     model7e2b110f6d81_mctd_foursurf(stan::io::var_context& context__,
  67 :         std::ostream* pstream__ = 0)
  68 :         : prob_grad(0) {
  69 :         typedef boost::ecuyer1988 rng_t;
  70 :         rng_t base_rng(0);  // 0 seed default
  71 :         ctor_body(context__, base_rng, pstream__);
  72 :     }
  73 : 
  74 :     template <class RNG>
  75 :     model7e2b110f6d81_mctd_foursurf(stan::io::var_context& context__,
  76 :         RNG& base_rng__,
  77 :         std::ostream* pstream__ = 0)
  78 :         : prob_grad(0) {
  79 :         ctor_body(context__, base_rng__, pstream__);
  80 :     }
  81 : 
  82 :     template <class RNG>
  83 :     void ctor_body(stan::io::var_context& context__,
  84 :                    RNG& base_rng__,
  85 :                    std::ostream* pstream__) {
  86 :         current_statement_begin__ = -1;
  87 : 
  88 :         static const char* function__ = "model7e2b110f6d81_mctd_foursurf_namespace::model7e2b110f6d81_mctd_foursurf";
  89 :         (void) function__; // dummy call to supress warning
  90 :         size_t pos__;
  91 :         (void) pos__; // dummy call to supress warning
  92 :         std::vector<int> vals_i__;
  93 :         std::vector<double> vals_r__;
  94 :         context__.validate_dims("data initialization", "N", "int", context__.to_vec());
  95 :         N = int(0);
  96 :         vals_i__ = context__.vals_i("N");
  97 :         pos__ = 0;
  98 :         N = vals_i__[pos__++];
  99 :         context__.validate_dims("data initialization", "T", "int", context__.to_vec());
 100 :         T = int(0);
 101 :         vals_i__ = context__.vals_i("T");
 102 :         pos__ = 0;
 103 :         T = vals_i__[pos__++];
 104 :         context__.validate_dims("data initialization", "C", "int", context__.to_vec());
 105 :         C = int(0);
 106 :         vals_i__ = context__.vals_i("C");
 107 :         pos__ = 0;
 108 :         C = vals_i__[pos__++];
 109 :         context__.validate_dims("data initialization", "tube", "int", context__.to_vec(N));
 110 :         validate_non_negative_index("tube", "N", N);
 111 :         tube = std::vector<int>(N,int(0));
 112 :         vals_i__ = context__.vals_i("tube");
 113 :         pos__ = 0;
 114 :         size_t tube_limit_0__ = N;
 115 :         for (size_t i_0__ = 0; i_0__ < tube_limit_0__; ++i_0__) {
 116 :             tube[i_0__] = vals_i__[pos__++];
 117 :         }
 118 :         context__.validate_dims("data initialization", "crop", "int", context__.to_vec(N));
 119 :         validate_non_negative_index("crop", "N", N);
 120 :         crop = std::vector<int>(N,int(0));
 121 :         vals_i__ = context__.vals_i("crop");
 122 :         pos__ = 0;
 123 :         size_t crop_limit_0__ = N;
 124 :         for (size_t i_0__ = 0; i_0__ < crop_limit_0__; ++i_0__) {
 125 :             crop[i_0__] = vals_i__[pos__++];
 126 :         }
 127 :         context__.validate_dims("data initialization", "depth", "double", context__.to_vec(N));
 128 :         validate_non_negative_index("depth", "N", N);
 129 :         depth = std::vector<double>(N,double(0));
 130 :         vals_r__ = context__.vals_r("depth");
 131 :         pos__ = 0;
 132 :         size_t depth_limit_0__ = N;
 133 :         for (size_t i_0__ = 0; i_0__ < depth_limit_0__; ++i_0__) {
 134 :             depth[i_0__] = vals_r__[pos__++];
 135 :         }
 136 :         validate_non_negative_index("y", "N", N);
 137 :         y = vector_d(static_cast<Eigen::VectorXd::Index>(N));
 138 :         context__.validate_dims("data initialization", "y", "vector_d", context__.to_vec(N));
 139 :         vals_r__ = context__.vals_r("y");
 140 :         pos__ = 0;
 141 :         size_t y_i_vec_lim__ = N;
 142 :         for (size_t i_vec__ = 0; i_vec__ < y_i_vec_lim__; ++i_vec__) {
 143 :             y[i_vec__] = vals_r__[pos__++];
 144 :         }
 145 :         context__.validate_dims("data initialization", "N_pred", "int", context__.to_vec());
 146 :         N_pred = int(0);
 147 :         vals_i__ = context__.vals_i("N_pred");
 148 :         pos__ = 0;
 149 :         N_pred = vals_i__[pos__++];
 150 :         context__.validate_dims("data initialization", "T_pred", "int", context__.to_vec());
 151 :         T_pred = int(0);
 152 :         vals_i__ = context__.vals_i("T_pred");
 153 :         pos__ = 0;
 154 :         T_pred = vals_i__[pos__++];
 155 :         context__.validate_dims("data initialization", "C_pred", "int", context__.to_vec());
 156 :         C_pred = int(0);
 157 :         vals_i__ = context__.vals_i("C_pred");
 158 :         pos__ = 0;
 159 :         C_pred = vals_i__[pos__++];
 160 :         context__.validate_dims("data initialization", "crop_pred", "int", context__.to_vec(N_pred));
 161 :         validate_non_negative_index("crop_pred", "N_pred", N_pred);
 162 :         crop_pred = std::vector<int>(N_pred,int(0));
 163 :         vals_i__ = context__.vals_i("crop_pred");
 164 :         pos__ = 0;
 165 :         size_t crop_pred_limit_0__ = N_pred;
 166 :         for (size_t i_0__ = 0; i_0__ < crop_pred_limit_0__; ++i_0__) {
 167 :             crop_pred[i_0__] = vals_i__[pos__++];
 168 :         }
 169 :         context__.validate_dims("data initialization", "tube_pred", "int", context__.to_vec(N_pred));
 170 :         validate_non_negative_index("tube_pred", "N_pred", N_pred);
 171 :         tube_pred = std::vector<int>(N_pred,int(0));
 172 :         vals_i__ = context__.vals_i("tube_pred");
 173 :         pos__ = 0;
 174 :         size_t tube_pred_limit_0__ = N_pred;
 175 :         for (size_t i_0__ = 0; i_0__ < tube_pred_limit_0__; ++i_0__) {
 176 :             tube_pred[i_0__] = vals_i__[pos__++];
 177 :         }
 178 :         context__.validate_dims("data initialization", "depth_pred", "double", context__.to_vec(N_pred));
 179 :         validate_non_negative_index("depth_pred", "N_pred", N_pred);
 180 :         depth_pred = std::vector<double>(N_pred,double(0));
 181 :         vals_r__ = context__.vals_r("depth_pred");
 182 :         pos__ = 0;
 183 :         size_t depth_pred_limit_0__ = N_pred;
 184 :         for (size_t i_0__ = 0; i_0__ < depth_pred_limit_0__; ++i_0__) {
 185 :             depth_pred[i_0__] = vals_r__[pos__++];
 186 :         }
 187 :         context__.validate_dims("data initialization", "sig_tube_prior_m", "double", context__.to_vec());
 188 :         sig_tube_prior_m = double(0);
 189 :         vals_r__ = context__.vals_r("sig_tube_prior_m");
 190 :         pos__ = 0;
 191 :         sig_tube_prior_m = vals_r__[pos__++];
 192 :         context__.validate_dims("data initialization", "sig_tube_prior_s", "double", context__.to_vec());
 193 :         sig_tube_prior_s = double(0);
 194 :         vals_r__ = context__.vals_r("sig_tube_prior_s");
 195 :         pos__ = 0;
 196 :         sig_tube_prior_s = vals_r__[pos__++];
 197 :         context__.validate_dims("data initialization", "sigma_prior_m", "double", context__.to_vec());
 198 :         sigma_prior_m = double(0);
 199 :         vals_r__ = context__.vals_r("sigma_prior_m");
 200 :         pos__ = 0;
 201 :         sigma_prior_m = vals_r__[pos__++];
 202 :         context__.validate_dims("data initialization", "sigma_prior_s", "double", context__.to_vec());
 203 :         sigma_prior_s = double(0);
 204 :         vals_r__ = context__.vals_r("sigma_prior_s");
 205 :         pos__ = 0;
 206 :         sigma_prior_s = vals_r__[pos__++];
 207 :         context__.validate_dims("data initialization", "intercept_prior_m", "double", context__.to_vec());
 208 :         intercept_prior_m = double(0);
 209 :         vals_r__ = context__.vals_r("intercept_prior_m");
 210 :         pos__ = 0;
 211 :         intercept_prior_m = vals_r__[pos__++];
 212 :         context__.validate_dims("data initialization", "intercept_prior_s", "double", context__.to_vec());
 213 :         intercept_prior_s = double(0);
 214 :         vals_r__ = context__.vals_r("intercept_prior_s");
 215 :         pos__ = 0;
 216 :         intercept_prior_s = vals_r__[pos__++];
 217 :         context__.validate_dims("data initialization", "b_depth_prior_m", "double", context__.to_vec());
 218 :         b_depth_prior_m = double(0);
 219 :         vals_r__ = context__.vals_r("b_depth_prior_m");
 220 :         pos__ = 0;
 221 :         b_depth_prior_m = vals_r__[pos__++];
 222 :         context__.validate_dims("data initialization", "b_depth_prior_s", "double", context__.to_vec());
 223 :         b_depth_prior_s = double(0);
 224 :         vals_r__ = context__.vals_r("b_depth_prior_s");
 225 :         pos__ = 0;
 226 :         b_depth_prior_s = vals_r__[pos__++];
 227 :         context__.validate_dims("data initialization", "loc_surface_prior_m", "double", context__.to_vec());
 228 :         loc_surface_prior_m = double(0);
 229 :         vals_r__ = context__.vals_r("loc_surface_prior_m");
 230 :         pos__ = 0;
 231 :         loc_surface_prior_m = vals_r__[pos__++];
 232 :         context__.validate_dims("data initialization", "loc_surface_prior_s", "double", context__.to_vec());
 233 :         loc_surface_prior_s = double(0);
 234 :         vals_r__ = context__.vals_r("loc_surface_prior_s");
 235 :         pos__ = 0;
 236 :         loc_surface_prior_s = vals_r__[pos__++];
 237 :         context__.validate_dims("data initialization", "scale_surface_prior_m", "double", context__.to_vec());
 238 :         scale_surface_prior_m = double(0);
 239 :         vals_r__ = context__.vals_r("scale_surface_prior_m");
 240 :         pos__ = 0;
 241 :         scale_surface_prior_m = vals_r__[pos__++];
 242 :         context__.validate_dims("data initialization", "scale_surface_prior_s", "double", context__.to_vec());
 243 :         scale_surface_prior_s = double(0);
 244 :         vals_r__ = context__.vals_r("scale_surface_prior_s");
 245 :         pos__ = 0;
 246 :         scale_surface_prior_s = vals_r__[pos__++];
 247 :         context__.validate_dims("data initialization", "loc_detect_prior_m", "double", context__.to_vec());
 248 :         loc_detect_prior_m = double(0);
 249 :         vals_r__ = context__.vals_r("loc_detect_prior_m");
 250 :         pos__ = 0;
 251 :         loc_detect_prior_m = vals_r__[pos__++];
 252 :         context__.validate_dims("data initialization", "loc_detect_prior_s", "double", context__.to_vec());
 253 :         loc_detect_prior_s = double(0);
 254 :         vals_r__ = context__.vals_r("loc_detect_prior_s");
 255 :         pos__ = 0;
 256 :         loc_detect_prior_s = vals_r__[pos__++];
 257 :         context__.validate_dims("data initialization", "scale_detect_prior_m", "double", context__.to_vec());
 258 :         scale_detect_prior_m = double(0);
 259 :         vals_r__ = context__.vals_r("scale_detect_prior_m");
 260 :         pos__ = 0;
 261 :         scale_detect_prior_m = vals_r__[pos__++];
 262 :         context__.validate_dims("data initialization", "scale_detect_prior_s", "double", context__.to_vec());
 263 :         scale_detect_prior_s = double(0);
 264 :         vals_r__ = context__.vals_r("scale_detect_prior_s");
 265 :         pos__ = 0;
 266 :         scale_detect_prior_s = vals_r__[pos__++];
 267 : 
 268 :         // validate data
 269 :         check_greater_or_equal(function__,"N",N,0);
 270 :         check_greater_or_equal(function__,"T",T,0);
 271 :         check_greater_or_equal(function__,"C",C,0);
 272 :         for (int k0__ = 0; k0__ < N; ++k0__) {
 273 :             check_greater_or_equal(function__,"tube[k0__]",tube[k0__],0);
 274 :             check_less_or_equal(function__,"tube[k0__]",tube[k0__],T);
 275 :         }
 276 :         for (int k0__ = 0; k0__ < N; ++k0__) {
 277 :             check_greater_or_equal(function__,"crop[k0__]",crop[k0__],1);
 278 :             check_less_or_equal(function__,"crop[k0__]",crop[k0__],C);
 279 :         }
 280 :         for (int k0__ = 0; k0__ < N; ++k0__) {
 281 :             check_greater_or_equal(function__,"depth[k0__]",depth[k0__],0);
 282 :         }
 283 :         check_greater_or_equal(function__,"y",y,0);
 284 :         check_greater_or_equal(function__,"N_pred",N_pred,0);
 285 :         check_greater_or_equal(function__,"T_pred",T_pred,0);
 286 :         check_greater_or_equal(function__,"C_pred",C_pred,0);
 287 :         for (int k0__ = 0; k0__ < N_pred; ++k0__) {
 288 :             check_greater_or_equal(function__,"crop_pred[k0__]",crop_pred[k0__],0);
 289 :             check_less_or_equal(function__,"crop_pred[k0__]",crop_pred[k0__],C_pred);
 290 :         }
 291 :         for (int k0__ = 0; k0__ < N_pred; ++k0__) {
 292 :             check_greater_or_equal(function__,"tube_pred[k0__]",tube_pred[k0__],0);
 293 :             check_less_or_equal(function__,"tube_pred[k0__]",tube_pred[k0__],T_pred);
 294 :         }
 295 :         for (int k0__ = 0; k0__ < N_pred; ++k0__) {
 296 :             check_greater_or_equal(function__,"depth_pred[k0__]",depth_pred[k0__],0);
 297 :         }
 298 :         check_greater_or_equal(function__,"sig_tube_prior_s",sig_tube_prior_s,0);
 299 :         check_greater_or_equal(function__,"sigma_prior_s",sigma_prior_s,0);
 300 :         check_greater_or_equal(function__,"intercept_prior_s",intercept_prior_s,0);
 301 :         check_greater_or_equal(function__,"b_depth_prior_s",b_depth_prior_s,0);
 302 :         check_greater_or_equal(function__,"loc_surface_prior_s",loc_surface_prior_s,0);
 303 :         check_greater_or_equal(function__,"scale_surface_prior_s",scale_surface_prior_s,0);
 304 :         check_greater_or_equal(function__,"loc_detect_prior_s",loc_detect_prior_s,0);
 305 :         check_greater_or_equal(function__,"scale_detect_prior_s",scale_detect_prior_s,0);
 306 :         depth_logmean = double(0);
 307 :         depth_pred_max = double(0);
 308 :         validate_non_negative_index("tube_crop_pred", "T_pred", T_pred);
 309 :         tube_crop_pred = std::vector<int>(T_pred,int(0));
 310 :         validate_non_negative_index("log_depth_centered", "N", N);
 311 :         log_depth_centered = std::vector<double>(N,double(0));
 312 :         validate_non_negative_index("log_depth_pred_centered", "N_pred", N_pred);
 313 :         log_depth_pred_centered = std::vector<double>(N_pred,double(0));
 314 :         validate_non_negative_index("y_logi", "N", N);
 315 :         y_logi = std::vector<int>(N,int(0));
 316 :         n_pos = int(0);
 317 : 
 318 :         double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 319 :         (void) DUMMY_VAR__;  // suppress unused var warning
 320 : 
 321 : 
 322 :         // initialize transformed variables to avoid seg fault on val access
 323 :         stan::math::fill(depth_logmean,DUMMY_VAR__);
 324 :         stan::math::fill(depth_pred_max,DUMMY_VAR__);
 325 :         stan::math::fill(tube_crop_pred, std::numeric_limits<int>::min());
 326 :         stan::math::fill(log_depth_centered,DUMMY_VAR__);
 327 :         stan::math::fill(log_depth_pred_centered,DUMMY_VAR__);
 328 :         stan::math::fill(y_logi, std::numeric_limits<int>::min());
 329 :         stan::math::fill(n_pos, std::numeric_limits<int>::min());
 330 : 
 331 :         try {
 332 :             current_statement_begin__ = 68;
 333 :             stan::math::assign(depth_logmean, log(mean(depth)));
 334 :             current_statement_begin__ = 69;
 335 :             stan::math::assign(depth_pred_max, max(depth_pred));
 336 :             current_statement_begin__ = 70;
 337 :             stan::math::assign(n_pos, 0);
 338 :             current_statement_begin__ = 71;
 339 :             for (int n = 1; n <= N; ++n) {
 340 :                 current_statement_begin__ = 72;
 341 :                 stan::math::assign(get_base1_lhs(log_depth_centered,n,"log_depth_centered",1), (log(get_base1(depth,n,"depth",1)) - depth_logmean));
 342 :                 current_statement_begin__ = 73;
 343 :                 if (as_bool(logical_gt(get_base1(y,n,"y",1),0))) {
 344 :                     current_statement_begin__ = 74;
 345 :                     stan::math::assign(get_base1_lhs(y_logi,n,"y_logi",1), 1);
 346 :                     current_statement_begin__ = 75;
 347 :                     stan::math::assign(n_pos, n);
 348 :                 } else {
 349 :                     current_statement_begin__ = 77;
 350 :                     stan::math::assign(get_base1_lhs(y_logi,n,"y_logi",1), 0);
 351 :                 }
 352 :             }
 353 :             current_statement_begin__ = 81;
 354 :             if (as_bool((primitive_value(logical_neq(sum(stan::model::rvalue(y_logi, stan::model::cons_list(stan::model::index_min_max((n_pos + 1), N), stan::model::nil_index_list()), "y_logi")),0)) || primitive_value(logical_neq(sum(stan::model::rvalue(y_logi, stan::model::cons_list(stan::model::index_min_max(1, n_pos), stan::model::nil_index_list()), "y_logi")),n_pos))))) {
 355 :                 current_statement_begin__ = 82;
 356 :                 std::stringstream errmsg_stream__;
 357 :                 errmsg_stream__ << "all observations with y==0 must appear at the end of the dataset";
 358 :                 throw std::domain_error(errmsg_stream__.str());
 359 :             }
 360 :             current_statement_begin__ = 85;
 361 :             for (int n = 1; n <= N_pred; ++n) {
 362 :                 current_statement_begin__ = 86;
 363 :                 stan::math::assign(get_base1_lhs(tube_crop_pred,get_base1(tube_pred,n,"tube_pred",1),"tube_crop_pred",1), get_base1(crop_pred,n,"crop_pred",1));
 364 :                 current_statement_begin__ = 87;
 365 :                 stan::math::assign(get_base1_lhs(log_depth_pred_centered,n,"log_depth_pred_centered",1), (log(get_base1(depth_pred,n,"depth_pred",1)) - depth_logmean));
 366 :             }
 367 :         } catch (const std::exception& e) {
 368 :             stan::lang::rethrow_located(e,current_statement_begin__);
 369 :             // Next line prevents compiler griping about no return
 370 :             throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
 371 :         }
 372 : 
 373 :         // validate transformed data
 374 :         for (int k0__ = 0; k0__ < T_pred; ++k0__) {
 375 :             check_greater_or_equal(function__,"tube_crop_pred[k0__]",tube_crop_pred[k0__],1);
 376 :             check_less_or_equal(function__,"tube_crop_pred[k0__]",tube_crop_pred[k0__],C_pred);
 377 :         }
 378 :         for (int k0__ = 0; k0__ < N; ++k0__) {
 379 :             check_greater_or_equal(function__,"y_logi[k0__]",y_logi[k0__],0);
 380 :             check_less_or_equal(function__,"y_logi[k0__]",y_logi[k0__],1);
 381 :         }
 382 :         check_greater_or_equal(function__,"n_pos",n_pos,0);
 383 :         check_less_or_equal(function__,"n_pos",n_pos,N);
 384 : 
 385 :         // set parameter ranges
 386 :         num_params_r__ = 0U;
 387 :         param_ranges_i__.clear();
 388 :         ++num_params_r__;
 389 :         ++num_params_r__;
 390 :         num_params_r__ += C;
 391 :         num_params_r__ += C;
 392 :         num_params_r__ += C;
 393 :         num_params_r__ += C;
 394 :         num_params_r__ += T;
 395 :         ++num_params_r__;
 396 :         num_params_r__ += C;
 397 :     }
 398 : 
 399 :     ~model7e2b110f6d81_mctd_foursurf() { }
 400 : 
 401 : 
 402 :     void transform_inits(const stan::io::var_context& context__,
 403 :                          std::vector<int>& params_i__,
 404 :                          std::vector<double>& params_r__,
 405 :                          std::ostream* pstream__) const {
 406 :         stan::io::writer<double> writer__(params_r__,params_i__);
 407 :         size_t pos__;
 408 :         (void) pos__; // dummy call to supress warning
 409 :         std::vector<double> vals_r__;
 410 :         std::vector<int> vals_i__;
 411 : 
 412 :         if (!(context__.contains_r("loc_detect")))
 413 :             throw std::runtime_error("variable loc_detect missing");
 414 :         vals_r__ = context__.vals_r("loc_detect");
 415 :         pos__ = 0U;
 416 :         context__.validate_dims("initialization", "loc_detect", "double", context__.to_vec());
 417 :         double loc_detect(0);
 418 :         loc_detect = vals_r__[pos__++];
 419 :         try {
 420 :             writer__.scalar_unconstrain(loc_detect);
 421 :         } catch (const std::exception& e) { 
 422 :             throw std::runtime_error(std::string("Error transforming variable loc_detect: ") + e.what());
 423 :         }
 424 : 
 425 :         if (!(context__.contains_r("scale_detect")))
 426 :             throw std::runtime_error("variable scale_detect missing");
 427 :         vals_r__ = context__.vals_r("scale_detect");
 428 :         pos__ = 0U;
 429 :         context__.validate_dims("initialization", "scale_detect", "double", context__.to_vec());
 430 :         double scale_detect(0);
 431 :         scale_detect = vals_r__[pos__++];
 432 :         try {
 433 :             writer__.scalar_lb_unconstrain(0,scale_detect);
 434 :         } catch (const std::exception& e) { 
 435 :             throw std::runtime_error(std::string("Error transforming variable scale_detect: ") + e.what());
 436 :         }
 437 : 
 438 :         if (!(context__.contains_r("loc_surface")))
 439 :             throw std::runtime_error("variable loc_surface missing");
 440 :         vals_r__ = context__.vals_r("loc_surface");
 441 :         pos__ = 0U;
 442 :         context__.validate_dims("initialization", "loc_surface", "vector_d", context__.to_vec(C));
 443 :         vector_d loc_surface(static_cast<Eigen::VectorXd::Index>(C));
 444 :         for (int j1__ = 0U; j1__ < C; ++j1__)
 445 :             loc_surface(j1__) = vals_r__[pos__++];
 446 :         try {
 447 :             writer__.vector_unconstrain(loc_surface);
 448 :         } catch (const std::exception& e) { 
 449 :             throw std::runtime_error(std::string("Error transforming variable loc_surface: ") + e.what());
 450 :         }
 451 : 
 452 :         if (!(context__.contains_r("scale_surface")))
 453 :             throw std::runtime_error("variable scale_surface missing");
 454 :         vals_r__ = context__.vals_r("scale_surface");
 455 :         pos__ = 0U;
 456 :         context__.validate_dims("initialization", "scale_surface", "vector_d", context__.to_vec(C));
 457 :         vector_d scale_surface(static_cast<Eigen::VectorXd::Index>(C));
 458 :         for (int j1__ = 0U; j1__ < C; ++j1__)
 459 :             scale_surface(j1__) = vals_r__[pos__++];
 460 :         try {
 461 :             writer__.vector_lb_unconstrain(0,scale_surface);
 462 :         } catch (const std::exception& e) { 
 463 :             throw std::runtime_error(std::string("Error transforming variable scale_surface: ") + e.what());
 464 :         }
 465 : 
 466 :         if (!(context__.contains_r("intercept")))
 467 :             throw std::runtime_error("variable intercept missing");
 468 :         vals_r__ = context__.vals_r("intercept");
 469 :         pos__ = 0U;
 470 :         context__.validate_dims("initialization", "intercept", "vector_d", context__.to_vec(C));
 471 :         vector_d intercept(static_cast<Eigen::VectorXd::Index>(C));
 472 :         for (int j1__ = 0U; j1__ < C; ++j1__)
 473 :             intercept(j1__) = vals_r__[pos__++];
 474 :         try {
 475 :             writer__.vector_unconstrain(intercept);
 476 :         } catch (const std::exception& e) { 
 477 :             throw std::runtime_error(std::string("Error transforming variable intercept: ") + e.what());
 478 :         }
 479 : 
 480 :         if (!(context__.contains_r("b_depth")))
 481 :             throw std::runtime_error("variable b_depth missing");
 482 :         vals_r__ = context__.vals_r("b_depth");
 483 :         pos__ = 0U;
 484 :         context__.validate_dims("initialization", "b_depth", "vector_d", context__.to_vec(C));
 485 :         vector_d b_depth(static_cast<Eigen::VectorXd::Index>(C));
 486 :         for (int j1__ = 0U; j1__ < C; ++j1__)
 487 :             b_depth(j1__) = vals_r__[pos__++];
 488 :         try {
 489 :             writer__.vector_unconstrain(b_depth);
 490 :         } catch (const std::exception& e) { 
 491 :             throw std::runtime_error(std::string("Error transforming variable b_depth: ") + e.what());
 492 :         }
 493 : 
 494 :         if (!(context__.contains_r("b_tube")))
 495 :             throw std::runtime_error("variable b_tube missing");
 496 :         vals_r__ = context__.vals_r("b_tube");
 497 :         pos__ = 0U;
 498 :         context__.validate_dims("initialization", "b_tube", "vector_d", context__.to_vec(T));
 499 :         vector_d b_tube(static_cast<Eigen::VectorXd::Index>(T));
 500 :         for (int j1__ = 0U; j1__ < T; ++j1__)
 501 :             b_tube(j1__) = vals_r__[pos__++];
 502 :         try {
 503 :             writer__.vector_unconstrain(b_tube);
 504 :         } catch (const std::exception& e) { 
 505 :             throw std::runtime_error(std::string("Error transforming variable b_tube: ") + e.what());
 506 :         }
 507 : 
 508 :         if (!(context__.contains_r("sig_tube")))
 509 :             throw std::runtime_error("variable sig_tube missing");
 510 :         vals_r__ = context__.vals_r("sig_tube");
 511 :         pos__ = 0U;
 512 :         context__.validate_dims("initialization", "sig_tube", "double", context__.to_vec());
 513 :         double sig_tube(0);
 514 :         sig_tube = vals_r__[pos__++];
 515 :         try {
 516 :             writer__.scalar_lb_unconstrain(0,sig_tube);
 517 :         } catch (const std::exception& e) { 
 518 :             throw std::runtime_error(std::string("Error transforming variable sig_tube: ") + e.what());
 519 :         }
 520 : 
 521 :         if (!(context__.contains_r("sigma")))
 522 :             throw std::runtime_error("variable sigma missing");
 523 :         vals_r__ = context__.vals_r("sigma");
 524 :         pos__ = 0U;
 525 :         context__.validate_dims("initialization", "sigma", "double", context__.to_vec(C));
 526 :         std::vector<double> sigma(C,double(0));
 527 :         for (int i0__ = 0U; i0__ < C; ++i0__)
 528 :             sigma[i0__] = vals_r__[pos__++];
 529 :         for (int i0__ = 0U; i0__ < C; ++i0__)
 530 :             try {
 531 :             writer__.scalar_lb_unconstrain(0,sigma[i0__]);
 532 :         } catch (const std::exception& e) { 
 533 :             throw std::runtime_error(std::string("Error transforming variable sigma: ") + e.what());
 534 :         }
 535 : 
 536 :         params_r__ = writer__.data_r();
 537 :         params_i__ = writer__.data_i();
 538 :     }
 539 : 
 540 :     void transform_inits(const stan::io::var_context& context,
 541 :                          Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
 542 :                          std::ostream* pstream__) const {
 543 :       std::vector<double> params_r_vec;
 544 :       std::vector<int> params_i_vec;
 545 :       transform_inits(context, params_i_vec, params_r_vec, pstream__);
 546 :       params_r.resize(params_r_vec.size());
 547 :       for (int i = 0; i < params_r.size(); ++i)
 548 :         params_r(i) = params_r_vec[i];
 549 :     }
 550 : 
 551 : 
 552 :     template <bool propto__, bool jacobian__, typename T__>
 553 :     T__ log_prob(vector<T__>& params_r__,
 554 :                  vector<int>& params_i__,
 555 :                  std::ostream* pstream__ = 0) const {
 556 : 
 557 :         T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 558 :         (void) DUMMY_VAR__;  // suppress unused var warning
 559 : 
 560 :         T__ lp__(0.0);
 561 :         stan::math::accumulator<T__> lp_accum__;
 562 : 
 563 :         // model parameters
 564 :         stan::io::reader<T__> in__(params_r__,params_i__);
 565 : 
 566 :         T__ loc_detect;
 567 :         (void) loc_detect;  // dummy to suppress unused var warning
 568 :         if (jacobian__)
 569 :             loc_detect = in__.scalar_constrain(lp__);
 570 :         else
 571 :             loc_detect = in__.scalar_constrain();
 572 : 
 573 :         T__ scale_detect;
 574 :         (void) scale_detect;  // dummy to suppress unused var warning
 575 :         if (jacobian__)
 576 :             scale_detect = in__.scalar_lb_constrain(0,lp__);
 577 :         else
 578 :             scale_detect = in__.scalar_lb_constrain(0);
 579 : 
 580 :         Eigen::Matrix<T__,Eigen::Dynamic,1>  loc_surface;
 581 :         (void) loc_surface;  // dummy to suppress unused var warning
 582 :         if (jacobian__)
 583 :             loc_surface = in__.vector_constrain(C,lp__);
 584 :         else
 585 :             loc_surface = in__.vector_constrain(C);
 586 : 
 587 :         Eigen::Matrix<T__,Eigen::Dynamic,1>  scale_surface;
 588 :         (void) scale_surface;  // dummy to suppress unused var warning
 589 :         if (jacobian__)
 590 :             scale_surface = in__.vector_lb_constrain(0,C,lp__);
 591 :         else
 592 :             scale_surface = in__.vector_lb_constrain(0,C);
 593 : 
 594 :         Eigen::Matrix<T__,Eigen::Dynamic,1>  intercept;
 595 :         (void) intercept;  // dummy to suppress unused var warning
 596 :         if (jacobian__)
 597 :             intercept = in__.vector_constrain(C,lp__);
 598 :         else
 599 :             intercept = in__.vector_constrain(C);
 600 : 
 601 :         Eigen::Matrix<T__,Eigen::Dynamic,1>  b_depth;
 602 :         (void) b_depth;  // dummy to suppress unused var warning
 603 :         if (jacobian__)
 604 :             b_depth = in__.vector_constrain(C,lp__);
 605 :         else
 606 :             b_depth = in__.vector_constrain(C);
 607 : 
 608 :         Eigen::Matrix<T__,Eigen::Dynamic,1>  b_tube;
 609 :         (void) b_tube;  // dummy to suppress unused var warning
 610 :         if (jacobian__)
 611 :             b_tube = in__.vector_constrain(T,lp__);
 612 :         else
 613 :             b_tube = in__.vector_constrain(T);
 614 : 
 615 :         T__ sig_tube;
 616 :         (void) sig_tube;  // dummy to suppress unused var warning
 617 :         if (jacobian__)
 618 :             sig_tube = in__.scalar_lb_constrain(0,lp__);
 619 :         else
 620 :             sig_tube = in__.scalar_lb_constrain(0);
 621 : 
 622 :         vector<T__> sigma;
 623 :         size_t dim_sigma_0__ = C;
 624 :         sigma.reserve(dim_sigma_0__);
 625 :         for (size_t k_0__ = 0; k_0__ < dim_sigma_0__; ++k_0__) {
 626 :             if (jacobian__)
 627 :                 sigma.push_back(in__.scalar_lb_constrain(0,lp__));
 628 :             else
 629 :                 sigma.push_back(in__.scalar_lb_constrain(0));
 630 :         }
 631 : 
 632 : 
 633 :         // transformed parameters
 634 :         Eigen::Matrix<T__,Eigen::Dynamic,1>  mu(static_cast<Eigen::VectorXd::Index>(N));
 635 :         (void) mu;  // dummy to suppress unused var warning
 636 :         Eigen::Matrix<T__,Eigen::Dynamic,1>  mu_obs(static_cast<Eigen::VectorXd::Index>(N));
 637 :         (void) mu_obs;  // dummy to suppress unused var warning
 638 :         Eigen::Matrix<T__,Eigen::Dynamic,1>  detect_odds(static_cast<Eigen::VectorXd::Index>(N));
 639 :         (void) detect_odds;  // dummy to suppress unused var warning
 640 :         Eigen::Matrix<T__,Eigen::Dynamic,1>  sig(static_cast<Eigen::VectorXd::Index>(n_pos));
 641 :         (void) sig;  // dummy to suppress unused var warning
 642 : 
 643 :         // initialize transformed variables to avoid seg fault on val access
 644 :         stan::math::fill(mu,DUMMY_VAR__);
 645 :         stan::math::fill(mu_obs,DUMMY_VAR__);
 646 :         stan::math::fill(detect_odds,DUMMY_VAR__);
 647 :         stan::math::fill(sig,DUMMY_VAR__);
 648 : 
 649 :         try {
 650 :             current_statement_begin__ = 120;
 651 :             for (int n = 1; n <= N; ++n) {
 652 :                 current_statement_begin__ = 123;
 653 :                 stan::math::assign(get_base1_lhs(mu,n,"mu",1), ((get_base1(intercept,get_base1(crop,n,"crop",1),"intercept",1) + get_base1(b_tube,get_base1(tube,n,"tube",1),"b_tube",1)) + (get_base1(b_depth,get_base1(crop,n,"crop",1),"b_depth",1) * get_base1(log_depth_centered,n,"log_depth_centered",1))));
 654 :                 current_statement_begin__ = 126;
 655 :                 stan::math::assign(get_base1_lhs(mu_obs,n,"mu_obs",1), (get_base1(mu,n,"mu",1) + log_inv_logit(((get_base1(depth,n,"depth",1) - get_base1(loc_surface,get_base1(crop,n,"crop",1),"loc_surface",1)) / get_base1(scale_surface,get_base1(crop,n,"crop",1),"scale_surface",1)))));
 656 :                 current_statement_begin__ = 128;
 657 :                 if (as_bool(logical_lte(n,n_pos))) {
 658 :                     current_statement_begin__ = 129;
 659 :                     stan::math::assign(get_base1_lhs(sig,n,"sig",1), get_base1(sigma,get_base1(crop,n,"crop",1),"sigma",1));
 660 :                 }
 661 :             }
 662 :             current_statement_begin__ = 134;
 663 :             stan::math::assign(detect_odds, divide(subtract(mu_obs,loc_detect),scale_detect));
 664 :         } catch (const std::exception& e) {
 665 :             stan::lang::rethrow_located(e,current_statement_begin__);
 666 :             // Next line prevents compiler griping about no return
 667 :             throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
 668 :         }
 669 : 
 670 :         // validate transformed parameters
 671 :         for (int i0__ = 0; i0__ < N; ++i0__) {
 672 :             if (stan::math::is_uninitialized(mu(i0__))) {
 673 :                 std::stringstream msg__;
 674 :                 msg__ << "Undefined transformed parameter: mu" << '[' << i0__ << ']';
 675 :                 throw std::runtime_error(msg__.str());
 676 :             }
 677 :         }
 678 :         for (int i0__ = 0; i0__ < N; ++i0__) {
 679 :             if (stan::math::is_uninitialized(mu_obs(i0__))) {
 680 :                 std::stringstream msg__;
 681 :                 msg__ << "Undefined transformed parameter: mu_obs" << '[' << i0__ << ']';
 682 :                 throw std::runtime_error(msg__.str());
 683 :             }
 684 :         }
 685 :         for (int i0__ = 0; i0__ < N; ++i0__) {
 686 :             if (stan::math::is_uninitialized(detect_odds(i0__))) {
 687 :                 std::stringstream msg__;
 688 :                 msg__ << "Undefined transformed parameter: detect_odds" << '[' << i0__ << ']';
 689 :                 throw std::runtime_error(msg__.str());
 690 :             }
 691 :         }
 692 :         for (int i0__ = 0; i0__ < n_pos; ++i0__) {
 693 :             if (stan::math::is_uninitialized(sig(i0__))) {
 694 :                 std::stringstream msg__;
 695 :                 msg__ << "Undefined transformed parameter: sig" << '[' << i0__ << ']';
 696 :                 throw std::runtime_error(msg__.str());
 697 :             }
 698 :         }
 699 : 
 700 :         const char* function__ = "validate transformed params";
 701 :         (void) function__;  // dummy to suppress unused var warning
 702 :         check_greater_or_equal(function__,"sig",sig,0);
 703 : 
 704 :         // model body
 705 :         try {
 706 :             current_statement_begin__ = 139;
 707 :             lp_accum__.add(normal_log<propto__>(sig_tube, sig_tube_prior_m, sig_tube_prior_s));
 708 :             current_statement_begin__ = 140;
 709 :             lp_accum__.add(normal_log<propto__>(b_tube, 0, sig_tube));
 710 :             current_statement_begin__ = 141;
 711 :             lp_accum__.add(normal_log<propto__>(sigma, sigma_prior_m, sigma_prior_s));
 712 :             current_statement_begin__ = 142;
 713 :             lp_accum__.add(normal_log<propto__>(intercept, intercept_prior_m, intercept_prior_s));
 714 :             current_statement_begin__ = 143;
 715 :             lp_accum__.add(normal_log<propto__>(b_depth, b_depth_prior_m, b_depth_prior_s));
 716 :             current_statement_begin__ = 144;
 717 :             lp_accum__.add(normal_log<propto__>(loc_surface, loc_surface_prior_m, loc_surface_prior_s));
 718 :             current_statement_begin__ = 145;
 719 :             lp_accum__.add(normal_log<propto__>(scale_surface, scale_surface_prior_m, scale_surface_prior_s));
 720 :             current_statement_begin__ = 146;
 721 :             lp_accum__.add(normal_log<propto__>(loc_detect, loc_detect_prior_m, loc_detect_prior_s));
 722 :             current_statement_begin__ = 147;
 723 :             lp_accum__.add(normal_log<propto__>(scale_detect, scale_detect_prior_m, scale_detect_prior_s));
 724 :             current_statement_begin__ = 149;
 725 :             lp_accum__.add(bernoulli_logit_log<propto__>(y_logi, detect_odds));
 726 :             current_statement_begin__ = 150;
 727 :             lp_accum__.add(lognormal_log<propto__>(segment(y,1,n_pos), segment(mu_obs,1,n_pos), sig));
 728 :         } catch (const std::exception& e) {
 729 :             stan::lang::rethrow_located(e,current_statement_begin__);
 730 :             // Next line prevents compiler griping about no return
 731 :             throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
 732 :         }
 733 : 
 734 :         lp_accum__.add(lp__);
 735 :         return lp_accum__.sum();
 736 : 
 737 :     } // log_prob()
 738 : 
 739 :     template <bool propto, bool jacobian, typename T_>
 740 :     T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
 741 :                std::ostream* pstream = 0) const {
 742 :       std::vector<T_> vec_params_r;
 743 :       vec_params_r.reserve(params_r.size());
 744 :       for (int i = 0; i < params_r.size(); ++i)
 745 :         vec_params_r.push_back(params_r(i));
 746 :       std::vector<int> vec_params_i;
 747 :       return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
 748 :     }
 749 : 
 750 : 
 751 :     void get_param_names(std::vector<std::string>& names__) const {
 752 :         names__.resize(0);
 753 :         names__.push_back("loc_detect");
 754 :         names__.push_back("scale_detect");
 755 :         names__.push_back("loc_surface");
 756 :         names__.push_back("scale_surface");
 757 :         names__.push_back("intercept");
 758 :         names__.push_back("b_depth");
 759 :         names__.push_back("b_tube");
 760 :         names__.push_back("sig_tube");
 761 :         names__.push_back("sigma");
 762 :         names__.push_back("mu");
 763 :         names__.push_back("mu_obs");
 764 :         names__.push_back("detect_odds");
 765 :         names__.push_back("sig");
 766 :         names__.push_back("b_tube_pred");
 767 :         names__.push_back("pred_tot");
 768 :         names__.push_back("mu_pred");
 769 :         names__.push_back("mu_obs_pred");
 770 :         names__.push_back("detect_odds_pred");
 771 :         names__.push_back("y_pred");
 772 :         names__.push_back("crop_tot");
 773 :         names__.push_back("crop_tot_diff");
 774 :         names__.push_back("crop_int_diff");
 775 :         names__.push_back("crop_bdepth_diff");
 776 :     }
 777 : 
 778 : 
 779 :     void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
 780 :         dimss__.resize(0);
 781 :         std::vector<size_t> dims__;
 782 :         dims__.resize(0);
 783 :         dimss__.push_back(dims__);
 784 :         dims__.resize(0);
 785 :         dimss__.push_back(dims__);
 786 :         dims__.resize(0);
 787 :         dims__.push_back(C);
 788 :         dimss__.push_back(dims__);
 789 :         dims__.resize(0);
 790 :         dims__.push_back(C);
 791 :         dimss__.push_back(dims__);
 792 :         dims__.resize(0);
 793 :         dims__.push_back(C);
 794 :         dimss__.push_back(dims__);
 795 :         dims__.resize(0);
 796 :         dims__.push_back(C);
 797 :         dimss__.push_back(dims__);
 798 :         dims__.resize(0);
 799 :         dims__.push_back(T);
 800 :         dimss__.push_back(dims__);
 801 :         dims__.resize(0);
 802 :         dimss__.push_back(dims__);
 803 :         dims__.resize(0);
 804 :         dims__.push_back(C);
 805 :         dimss__.push_back(dims__);
 806 :         dims__.resize(0);
 807 :         dims__.push_back(N);
 808 :         dimss__.push_back(dims__);
 809 :         dims__.resize(0);
 810 :         dims__.push_back(N);
 811 :         dimss__.push_back(dims__);
 812 :         dims__.resize(0);
 813 :         dims__.push_back(N);
 814 :         dimss__.push_back(dims__);
 815 :         dims__.resize(0);
 816 :         dims__.push_back(n_pos);
 817 :         dimss__.push_back(dims__);
 818 :         dims__.resize(0);
 819 :         dims__.push_back(T_pred);
 820 :         dimss__.push_back(dims__);
 821 :         dims__.resize(0);
 822 :         dims__.push_back(T_pred);
 823 :         dimss__.push_back(dims__);
 824 :         dims__.resize(0);
 825 :         dims__.push_back(N_pred);
 826 :         dimss__.push_back(dims__);
 827 :         dims__.resize(0);
 828 :         dims__.push_back(N_pred);
 829 :         dimss__.push_back(dims__);
 830 :         dims__.resize(0);
 831 :         dims__.push_back(N_pred);
 832 :         dimss__.push_back(dims__);
 833 :         dims__.resize(0);
 834 :         dims__.push_back(N_pred);
 835 :         dimss__.push_back(dims__);
 836 :         dims__.resize(0);
 837 :         dims__.push_back(C);
 838 :         dimss__.push_back(dims__);
 839 :         dims__.resize(0);
 840 :         dims__.push_back((C - 1));
 841 :         dimss__.push_back(dims__);
 842 :         dims__.resize(0);
 843 :         dims__.push_back((C - 1));
 844 :         dimss__.push_back(dims__);
 845 :         dims__.resize(0);
 846 :         dims__.push_back((C - 1));
 847 :         dimss__.push_back(dims__);
 848 :     }
 849 : 
 850 :     template <typename RNG>
 851 :     void write_array(RNG& base_rng__,
 852 :                      std::vector<double>& params_r__,
 853 :                      std::vector<int>& params_i__,
 854 :                      std::vector<double>& vars__,
 855 :                      bool include_tparams__ = true,
 856 :                      bool include_gqs__ = true,
 857 :                      std::ostream* pstream__ = 0) const {
 858 :         vars__.resize(0);
 859 :         stan::io::reader<double> in__(params_r__,params_i__);
 860 :         static const char* function__ = "model7e2b110f6d81_mctd_foursurf_namespace::write_array";
 861 :         (void) function__; // dummy call to supress warning
 862 :         // read-transform, write parameters
 863 :         double loc_detect = in__.scalar_constrain();
 864 :         double scale_detect = in__.scalar_lb_constrain(0);
 865 :         vector_d loc_surface = in__.vector_constrain(C);
 866 :         vector_d scale_surface = in__.vector_lb_constrain(0,C);
 867 :         vector_d intercept = in__.vector_constrain(C);
 868 :         vector_d b_depth = in__.vector_constrain(C);
 869 :         vector_d b_tube = in__.vector_constrain(T);
 870 :         double sig_tube = in__.scalar_lb_constrain(0);
 871 :         vector<double> sigma;
 872 :         size_t dim_sigma_0__ = C;
 873 :         for (size_t k_0__ = 0; k_0__ < dim_sigma_0__; ++k_0__) {
 874 :             sigma.push_back(in__.scalar_lb_constrain(0));
 875 :         }
 876 :         vars__.push_back(loc_detect);
 877 :         vars__.push_back(scale_detect);
 878 :         for (int k_0__ = 0; k_0__ < C; ++k_0__) {
 879 :             vars__.push_back(loc_surface[k_0__]);
 880 :         }
 881 :         for (int k_0__ = 0; k_0__ < C; ++k_0__) {
 882 :             vars__.push_back(scale_surface[k_0__]);
 883 :         }
 884 :         for (int k_0__ = 0; k_0__ < C; ++k_0__) {
 885 :             vars__.push_back(intercept[k_0__]);
 886 :         }
 887 :         for (int k_0__ = 0; k_0__ < C; ++k_0__) {
 888 :             vars__.push_back(b_depth[k_0__]);
 889 :         }
 890 :         for (int k_0__ = 0; k_0__ < T; ++k_0__) {
 891 :             vars__.push_back(b_tube[k_0__]);
 892 :         }
 893 :         vars__.push_back(sig_tube);
 894 :         for (int k_0__ = 0; k_0__ < C; ++k_0__) {
 895 :             vars__.push_back(sigma[k_0__]);
 896 :         }
 897 : 
 898 :         if (!include_tparams__) return;
 899 :         // declare and define transformed parameters
 900 :         double lp__ = 0.0;
 901 :         (void) lp__; // dummy call to supress warning
 902 :         stan::math::accumulator<double> lp_accum__;
 903 : 
 904 :         vector_d mu(static_cast<Eigen::VectorXd::Index>(N));
 905 :         (void) mu;  // dummy to suppress unused var warning
 906 :         vector_d mu_obs(static_cast<Eigen::VectorXd::Index>(N));
 907 :         (void) mu_obs;  // dummy to suppress unused var warning
 908 :         vector_d detect_odds(static_cast<Eigen::VectorXd::Index>(N));
 909 :         (void) detect_odds;  // dummy to suppress unused var warning
 910 :         vector_d sig(static_cast<Eigen::VectorXd::Index>(n_pos));
 911 :         (void) sig;  // dummy to suppress unused var warning
 912 : 
 913 :         try {
 914 :             current_statement_begin__ = 120;
 915 :             for (int n = 1; n <= N; ++n) {
 916 :                 current_statement_begin__ = 123;
 917 :                 stan::math::assign(get_base1_lhs(mu,n,"mu",1), ((get_base1(intercept,get_base1(crop,n,"crop",1),"intercept",1) + get_base1(b_tube,get_base1(tube,n,"tube",1),"b_tube",1)) + (get_base1(b_depth,get_base1(crop,n,"crop",1),"b_depth",1) * get_base1(log_depth_centered,n,"log_depth_centered",1))));
 918 :                 current_statement_begin__ = 126;
 919 :                 stan::math::assign(get_base1_lhs(mu_obs,n,"mu_obs",1), (get_base1(mu,n,"mu",1) + log_inv_logit(((get_base1(depth,n,"depth",1) - get_base1(loc_surface,get_base1(crop,n,"crop",1),"loc_surface",1)) / get_base1(scale_surface,get_base1(crop,n,"crop",1),"scale_surface",1)))));
 920 :                 current_statement_begin__ = 128;
 921 :                 if (as_bool(logical_lte(n,n_pos))) {
 922 :                     current_statement_begin__ = 129;
 923 :                     stan::math::assign(get_base1_lhs(sig,n,"sig",1), get_base1(sigma,get_base1(crop,n,"crop",1),"sigma",1));
 924 :                 }
 925 :             }
 926 :             current_statement_begin__ = 134;
 927 :             stan::math::assign(detect_odds, divide(subtract(mu_obs,loc_detect),scale_detect));
 928 :         } catch (const std::exception& e) {
 929 :             stan::lang::rethrow_located(e,current_statement_begin__);
 930 :             // Next line prevents compiler griping about no return
 931 :             throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
 932 :         }
 933 : 
 934 :         // validate transformed parameters
 935 :         check_greater_or_equal(function__,"sig",sig,0);
 936 : 
 937 :         // write transformed parameters
 938 :         for (int k_0__ = 0; k_0__ < N; ++k_0__) {
 939 :             vars__.push_back(mu[k_0__]);
 940 :         }
 941 :         for (int k_0__ = 0; k_0__ < N; ++k_0__) {
 942 :             vars__.push_back(mu_obs[k_0__]);
 943 :         }
 944 :         for (int k_0__ = 0; k_0__ < N; ++k_0__) {
 945 :             vars__.push_back(detect_odds[k_0__]);
 946 :         }
 947 :         for (int k_0__ = 0; k_0__ < n_pos; ++k_0__) {
 948 :             vars__.push_back(sig[k_0__]);
 949 :         }
 950 : 
 951 :         if (!include_gqs__) return;
 952 :         // declare and define generated quantities
 953 :         vector<double> b_tube_pred(T_pred, 0.0);
 954 :         vector<double> pred_tot(T_pred, 0.0);
 955 :         vector<double> mu_pred(N_pred, 0.0);
 956 :         vector<double> mu_obs_pred(N_pred, 0.0);
 957 :         vector<double> detect_odds_pred(N_pred, 0.0);
 958 :         vector<double> y_pred(N_pred, 0.0);
 959 :         vector<double> crop_tot(C, 0.0);
 960 :         vector<double> crop_tot_diff((C - 1), 0.0);
 961 :         vector<double> crop_int_diff((C - 1), 0.0);
 962 :         vector<double> crop_bdepth_diff((C - 1), 0.0);
 963 : 
 964 :         double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
 965 :         (void) DUMMY_VAR__;  // suppress unused var warning
 966 : 
 967 : 
 968 :         // initialize transformed variables to avoid seg fault on val access
 969 :         stan::math::fill(b_tube_pred,DUMMY_VAR__);
 970 :         stan::math::fill(pred_tot,DUMMY_VAR__);
 971 :         stan::math::fill(mu_pred,DUMMY_VAR__);
 972 :         stan::math::fill(mu_obs_pred,DUMMY_VAR__);
 973 :         stan::math::fill(detect_odds_pred,DUMMY_VAR__);
 974 :         stan::math::fill(y_pred,DUMMY_VAR__);
 975 :         stan::math::fill(crop_tot,DUMMY_VAR__);
 976 :         stan::math::fill(crop_tot_diff,DUMMY_VAR__);
 977 :         stan::math::fill(crop_int_diff,DUMMY_VAR__);
 978 :         stan::math::fill(crop_bdepth_diff,DUMMY_VAR__);
 979 : 
 980 :         try {
 981 :             current_statement_begin__ = 169;
 982 :             for (int c = 1; c <= C; ++c) {
 983 :                 current_statement_begin__ = 170;
 984 :                 if (as_bool(logical_eq(get_base1(b_depth,c,"b_depth",1),-(1.0)))) {
 985 :                     current_statement_begin__ = 172;
 986 :                     stan::math::assign(get_base1_lhs(crop_tot,c,"crop_tot",1), (exp((get_base1(intercept,c,"intercept",1) - (get_base1(b_depth,c,"b_depth",1) * depth_logmean))) * log(depth_pred_max)));
 987 :                 } else {
 988 :                     current_statement_begin__ = 175;
 989 :                     stan::math::assign(get_base1_lhs(crop_tot,c,"crop_tot",1), ((exp((get_base1(intercept,c,"intercept",1) - (get_base1(b_depth,c,"b_depth",1) * depth_logmean))) * (pow(depth_pred_max,(get_base1(b_depth,c,"b_depth",1) + 1.0)) - 1.0)) / (get_base1(b_depth,c,"b_depth",1) + 1.0)));
 990 :                 }
 991 :             }
 992 :             current_statement_begin__ = 185;
 993 :             for (int c = 2; c <= C; ++c) {
 994 :                 current_statement_begin__ = 186;
 995 :                 stan::math::assign(get_base1_lhs(crop_tot_diff,(c - 1),"crop_tot_diff",1), (get_base1(crop_tot,c,"crop_tot",1) - get_base1(crop_tot,1,"crop_tot",1)));
 996 :                 current_statement_begin__ = 187;
 997 :                 stan::math::assign(get_base1_lhs(crop_int_diff,(c - 1),"crop_int_diff",1), (get_base1(intercept,c,"intercept",1) - get_base1(intercept,1,"intercept",1)));
 998 :                 current_statement_begin__ = 188;
 999 :                 stan::math::assign(get_base1_lhs(crop_bdepth_diff,(c - 1),"crop_bdepth_diff",1), (get_base1(b_depth,c,"b_depth",1) - get_base1(b_depth,1,"b_depth",1)));
1000 :             }
1001 :             current_statement_begin__ = 191;
1002 :             for (int t = 1; t <= T_pred; ++t) {
1003 :                 {
1004 :                     int tc(0);
1005 :                     (void) tc;  // dummy to suppress unused var warning
1006 :                     current_statement_begin__ = 193;
1007 :                     stan::math::assign(tc, get_base1(tube_crop_pred,t,"tube_crop_pred",1));
1008 :                     current_statement_begin__ = 196;
1009 :                     stan::math::assign(get_base1_lhs(b_tube_pred,t,"b_tube_pred",1), normal_rng(0,sig_tube, base_rng__));
1010 :                     current_statement_begin__ = 199;
1011 :                     if (as_bool(logical_eq(get_base1(b_depth,tc,"b_depth",1),-(1.0)))) {
1012 :                         current_statement_begin__ = 201;
1013 :                         stan::math::assign(get_base1_lhs(pred_tot,t,"pred_tot",1), (exp(((get_base1(intercept,tc,"intercept",1) - (get_base1(b_depth,tc,"b_depth",1) * depth_logmean)) + get_base1(b_tube_pred,t,"b_tube_pred",1))) * log(depth_pred_max)));
1014 :                     } else {
1015 :                         current_statement_begin__ = 205;
1016 :                         stan::math::assign(get_base1_lhs(pred_tot,t,"pred_tot",1), ((exp(((get_base1(intercept,tc,"intercept",1) - (get_base1(b_depth,tc,"b_depth",1) * depth_logmean)) + get_base1(b_tube_pred,t,"b_tube_pred",1))) * (pow(depth_pred_max,(get_base1(b_depth,tc,"b_depth",1) + 1)) - 1)) / (get_base1(b_depth,tc,"b_depth",1) + 1)));
1017 :                     }
1018 :                 }
1019 :             }
1020 :             current_statement_begin__ = 212;
1021 :             for (int n = 1; n <= N_pred; ++n) {
1022 :                 current_statement_begin__ = 213;
1023 :                 stan::math::assign(get_base1_lhs(mu_pred,n,"mu_pred",1), ((get_base1(intercept,get_base1(crop_pred,n,"crop_pred",1),"intercept",1) + get_base1(b_tube_pred,get_base1(tube_pred,n,"tube_pred",1),"b_tube_pred",1)) + (get_base1(b_depth,get_base1(crop_pred,n,"crop_pred",1),"b_depth",1) * get_base1(log_depth_pred_centered,n,"log_depth_pred_centered",1))));
1024 :                 current_statement_begin__ = 217;
1025 :                 stan::math::assign(get_base1_lhs(mu_obs_pred,n,"mu_obs_pred",1), (get_base1(mu_pred,n,"mu_pred",1) + log_inv_logit(((get_base1(depth_pred,n,"depth_pred",1) - get_base1(loc_surface,get_base1(crop_pred,n,"crop_pred",1),"loc_surface",1)) / get_base1(scale_surface,get_base1(crop_pred,n,"crop_pred",1),"scale_surface",1)))));
1026 :                 current_statement_begin__ = 221;
1027 :                 stan::math::assign(get_base1_lhs(detect_odds_pred,n,"detect_odds_pred",1), inv_logit(((get_base1(mu_obs_pred,n,"mu_obs_pred",1) - loc_detect) / scale_detect)));
1028 :                 current_statement_begin__ = 223;
1029 :                 stan::math::assign(get_base1_lhs(y_pred,n,"y_pred",1), (lognormal_rng(get_base1(mu_obs_pred,n,"mu_obs_pred",1),get_base1(sigma,get_base1(crop_pred,n,"crop_pred",1),"sigma",1), base_rng__) * bernoulli_rng(get_base1(detect_odds_pred,n,"detect_odds_pred",1), base_rng__)));
1030 :             }
1031 :         } catch (const std::exception& e) {
1032 :             stan::lang::rethrow_located(e,current_statement_begin__);
1033 :             // Next line prevents compiler griping about no return
1034 :             throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
1035 :         }
1036 : 
1037 :         // validate generated quantities
1038 :         for (int k0__ = 0; k0__ < T_pred; ++k0__) {
1039 :             check_greater_or_equal(function__,"pred_tot[k0__]",pred_tot[k0__],0);
1040 :         }
1041 :         for (int k0__ = 0; k0__ < N_pred; ++k0__) {
1042 :             check_greater_or_equal(function__,"y_pred[k0__]",y_pred[k0__],0);
1043 :         }
1044 :         for (int k0__ = 0; k0__ < C; ++k0__) {
1045 :             check_greater_or_equal(function__,"crop_tot[k0__]",crop_tot[k0__],0);
1046 :         }
1047 : 
1048 :         // write generated quantities
1049 :         for (int k_0__ = 0; k_0__ < T_pred; ++k_0__) {
1050 :             vars__.push_back(b_tube_pred[k_0__]);
1051 :         }
1052 :         for (int k_0__ = 0; k_0__ < T_pred; ++k_0__) {
1053 :             vars__.push_back(pred_tot[k_0__]);
1054 :         }
1055 :         for (int k_0__ = 0; k_0__ < N_pred; ++k_0__) {
1056 :             vars__.push_back(mu_pred[k_0__]);
1057 :         }
1058 :         for (int k_0__ = 0; k_0__ < N_pred; ++k_0__) {
1059 :             vars__.push_back(mu_obs_pred[k_0__]);
1060 :         }
1061 :         for (int k_0__ = 0; k_0__ < N_pred; ++k_0__) {
1062 :             vars__.push_back(detect_odds_pred[k_0__]);
1063 :         }
1064 :         for (int k_0__ = 0; k_0__ < N_pred; ++k_0__) {
1065 :             vars__.push_back(y_pred[k_0__]);
1066 :         }
1067 :         for (int k_0__ = 0; k_0__ < C; ++k_0__) {
1068 :             vars__.push_back(crop_tot[k_0__]);
1069 :         }
1070 :         for (int k_0__ = 0; k_0__ < (C - 1); ++k_0__) {
1071 :             vars__.push_back(crop_tot_diff[k_0__]);
1072 :         }
1073 :         for (int k_0__ = 0; k_0__ < (C - 1); ++k_0__) {
1074 :             vars__.push_back(crop_int_diff[k_0__]);
1075 :         }
1076 :         for (int k_0__ = 0; k_0__ < (C - 1); ++k_0__) {
1077 :             vars__.push_back(crop_bdepth_diff[k_0__]);
1078 :         }
1079 : 
1080 :     }
1081 : 
1082 :     template <typename RNG>
1083 :     void write_array(RNG& base_rng,
1084 :                      Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
1085 :                      Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
1086 :                      bool include_tparams = true,
1087 :                      bool include_gqs = true,
1088 :                      std::ostream* pstream = 0) const {
1089 :       std::vector<double> params_r_vec(params_r.size());
1090 :       for (int i = 0; i < params_r.size(); ++i)
1091 :         params_r_vec[i] = params_r(i);
1092 :       std::vector<double> vars_vec;
1093 :       std::vector<int> params_i_vec;
1094 :       write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
1095 :       vars.resize(vars_vec.size());
1096 :       for (int i = 0; i < vars.size(); ++i)
1097 :         vars(i) = vars_vec[i];
1098 :     }
1099 : 
1100 :     static std::string model_name() {
1101 :         return "model7e2b110f6d81_mctd_foursurf";
1102 :     }
1103 : 
1104 : 
1105 :     void constrained_param_names(std::vector<std::string>& param_names__,
1106 :                                  bool include_tparams__ = true,
1107 :                                  bool include_gqs__ = true) const {
1108 :         std::stringstream param_name_stream__;
1109 :         param_name_stream__.str(std::string());
1110 :         param_name_stream__ << "loc_detect";
1111 :         param_names__.push_back(param_name_stream__.str());
1112 :         param_name_stream__.str(std::string());
1113 :         param_name_stream__ << "scale_detect";
1114 :         param_names__.push_back(param_name_stream__.str());
1115 :         for (int k_0__ = 1; k_0__ <= C; ++k_0__) {
1116 :             param_name_stream__.str(std::string());
1117 :             param_name_stream__ << "loc_surface" << '.' << k_0__;
1118 :             param_names__.push_back(param_name_stream__.str());
1119 :         }
1120 :         for (int k_0__ = 1; k_0__ <= C; ++k_0__) {
1121 :             param_name_stream__.str(std::string());
1122 :             param_name_stream__ << "scale_surface" << '.' << k_0__;
1123 :             param_names__.push_back(param_name_stream__.str());
1124 :         }
1125 :         for (int k_0__ = 1; k_0__ <= C; ++k_0__) {
1126 :             param_name_stream__.str(std::string());
1127 :             param_name_stream__ << "intercept" << '.' << k_0__;
1128 :             param_names__.push_back(param_name_stream__.str());
1129 :         }
1130 :         for (int k_0__ = 1; k_0__ <= C; ++k_0__) {
1131 :             param_name_stream__.str(std::string());
1132 :             param_name_stream__ << "b_depth" << '.' << k_0__;
1133 :             param_names__.push_back(param_name_stream__.str());
1134 :         }
1135 :         for (int k_0__ = 1; k_0__ <= T; ++k_0__) {
1136 :             param_name_stream__.str(std::string());
1137 :             param_name_stream__ << "b_tube" << '.' << k_0__;
1138 :             param_names__.push_back(param_name_stream__.str());
1139 :         }
1140 :         param_name_stream__.str(std::string());
1141 :         param_name_stream__ << "sig_tube";
1142 :         param_names__.push_back(param_name_stream__.str());
1143 :         for (int k_0__ = 1; k_0__ <= C; ++k_0__) {
1144 :             param_name_stream__.str(std::string());
1145 :             param_name_stream__ << "sigma" << '.' << k_0__;
1146 :             param_names__.push_back(param_name_stream__.str());
1147 :         }
1148 : 
1149 :         if (!include_gqs__ && !include_tparams__) return;
1150 :         for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
1151 :             param_name_stream__.str(std::string());
1152 :             param_name_stream__ << "mu" << '.' << k_0__;
1153 :             param_names__.push_back(param_name_stream__.str());
1154 :         }
1155 :         for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
1156 :             param_name_stream__.str(std::string());
1157 :             param_name_stream__ << "mu_obs" << '.' << k_0__;
1158 :             param_names__.push_back(param_name_stream__.str());
1159 :         }
1160 :         for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
1161 :             param_name_stream__.str(std::string());
1162 :             param_name_stream__ << "detect_odds" << '.' << k_0__;
1163 :             param_names__.push_back(param_name_stream__.str());
1164 :         }
1165 :         for (int k_0__ = 1; k_0__ <= n_pos; ++k_0__) {
1166 :             param_name_stream__.str(std::string());
1167 :             param_name_stream__ << "sig" << '.' << k_0__;
1168 :             param_names__.push_back(param_name_stream__.str());
1169 :         }
1170 : 
1171 :         if (!include_gqs__) return;
1172 :         for (int k_0__ = 1; k_0__ <= T_pred; ++k_0__) {
1173 :             param_name_stream__.str(std::string());
1174 :             param_name_stream__ << "b_tube_pred" << '.' << k_0__;
1175 :             param_names__.push_back(param_name_stream__.str());
1176 :         }
1177 :         for (int k_0__ = 1; k_0__ <= T_pred; ++k_0__) {
1178 :             param_name_stream__.str(std::string());
1179 :             param_name_stream__ << "pred_tot" << '.' << k_0__;
1180 :             param_names__.push_back(param_name_stream__.str());
1181 :         }
1182 :         for (int k_0__ = 1; k_0__ <= N_pred; ++k_0__) {
1183 :             param_name_stream__.str(std::string());
1184 :             param_name_stream__ << "mu_pred" << '.' << k_0__;
1185 :             param_names__.push_back(param_name_stream__.str());
1186 :         }
1187 :         for (int k_0__ = 1; k_0__ <= N_pred; ++k_0__) {
1188 :             param_name_stream__.str(std::string());
1189 :             param_name_stream__ << "mu_obs_pred" << '.' << k_0__;
1190 :             param_names__.push_back(param_name_stream__.str());
1191 :         }
1192 :         for (int k_0__ = 1; k_0__ <= N_pred; ++k_0__) {
1193 :             param_name_stream__.str(std::string());
1194 :             param_name_stream__ << "detect_odds_pred" << '.' << k_0__;
1195 :             param_names__.push_back(param_name_stream__.str());
1196 :         }
1197 :         for (int k_0__ = 1; k_0__ <= N_pred; ++k_0__) {
1198 :             param_name_stream__.str(std::string());
1199 :             param_name_stream__ << "y_pred" << '.' << k_0__;
1200 :             param_names__.push_back(param_name_stream__.str());
1201 :         }
1202 :         for (int k_0__ = 1; k_0__ <= C; ++k_0__) {
1203 :             param_name_stream__.str(std::string());
1204 :             param_name_stream__ << "crop_tot" << '.' << k_0__;
1205 :             param_names__.push_back(param_name_stream__.str());
1206 :         }
1207 :         for (int k_0__ = 1; k_0__ <= (C - 1); ++k_0__) {
1208 :             param_name_stream__.str(std::string());
1209 :             param_name_stream__ << "crop_tot_diff" << '.' << k_0__;
1210 :             param_names__.push_back(param_name_stream__.str());
1211 :         }
1212 :         for (int k_0__ = 1; k_0__ <= (C - 1); ++k_0__) {
1213 :             param_name_stream__.str(std::string());
1214 :             param_name_stream__ << "crop_int_diff" << '.' << k_0__;
1215 :             param_names__.push_back(param_name_stream__.str());
1216 :         }
1217 :         for (int k_0__ = 1; k_0__ <= (C - 1); ++k_0__) {
1218 :             param_name_stream__.str(std::string());
1219 :             param_name_stream__ << "crop_bdepth_diff" << '.' << k_0__;
1220 :             param_names__.push_back(param_name_stream__.str());
1221 :         }
1222 :     }
1223 : 
1224 : 
1225 :     void unconstrained_param_names(std::vector<std::string>& param_names__,
1226 :                                    bool include_tparams__ = true,
1227 :                                    bool include_gqs__ = true) const {
1228 :         std::stringstream param_name_stream__;
1229 :         param_name_stream__.str(std::string());
1230 :         param_name_stream__ << "loc_detect";
1231 :         param_names__.push_back(param_name_stream__.str());
1232 :         param_name_stream__.str(std::string());
1233 :         param_name_stream__ << "scale_detect";
1234 :         param_names__.push_back(param_name_stream__.str());
1235 :         for (int k_0__ = 1; k_0__ <= C; ++k_0__) {
1236 :             param_name_stream__.str(std::string());
1237 :             param_name_stream__ << "loc_surface" << '.' << k_0__;
1238 :             param_names__.push_back(param_name_stream__.str());
1239 :         }
1240 :         for (int k_0__ = 1; k_0__ <= C; ++k_0__) {
1241 :             param_name_stream__.str(std::string());
1242 :             param_name_stream__ << "scale_surface" << '.' << k_0__;
1243 :             param_names__.push_back(param_name_stream__.str());
1244 :         }
1245 :         for (int k_0__ = 1; k_0__ <= C; ++k_0__) {
1246 :             param_name_stream__.str(std::string());
1247 :             param_name_stream__ << "intercept" << '.' << k_0__;
1248 :             param_names__.push_back(param_name_stream__.str());
1249 :         }
1250 :         for (int k_0__ = 1; k_0__ <= C; ++k_0__) {
1251 :             param_name_stream__.str(std::string());
1252 :             param_name_stream__ << "b_depth" << '.' << k_0__;
1253 :             param_names__.push_back(param_name_stream__.str());
1254 :         }
1255 :         for (int k_0__ = 1; k_0__ <= T; ++k_0__) {
1256 :             param_name_stream__.str(std::string());
1257 :             param_name_stream__ << "b_tube" << '.' << k_0__;
1258 :             param_names__.push_back(param_name_stream__.str());
1259 :         }
1260 :         param_name_stream__.str(std::string());
1261 :         param_name_stream__ << "sig_tube";
1262 :         param_names__.push_back(param_name_stream__.str());
1263 :         for (int k_0__ = 1; k_0__ <= C; ++k_0__) {
1264 :             param_name_stream__.str(std::string());
1265 :             param_name_stream__ << "sigma" << '.' << k_0__;
1266 :             param_names__.push_back(param_name_stream__.str());
1267 :         }
1268 : 
1269 :         if (!include_gqs__ && !include_tparams__) return;
1270 :         for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
1271 :             param_name_stream__.str(std::string());
1272 :             param_name_stream__ << "mu" << '.' << k_0__;
1273 :             param_names__.push_back(param_name_stream__.str());
1274 :         }
1275 :         for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
1276 :             param_name_stream__.str(std::string());
1277 :             param_name_stream__ << "mu_obs" << '.' << k_0__;
1278 :             param_names__.push_back(param_name_stream__.str());
1279 :         }
1280 :         for (int k_0__ = 1; k_0__ <= N; ++k_0__) {
1281 :             param_name_stream__.str(std::string());
1282 :             param_name_stream__ << "detect_odds" << '.' << k_0__;
1283 :             param_names__.push_back(param_name_stream__.str());
1284 :         }
1285 :         for (int k_0__ = 1; k_0__ <= n_pos; ++k_0__) {
1286 :             param_name_stream__.str(std::string());
1287 :             param_name_stream__ << "sig" << '.' << k_0__;
1288 :             param_names__.push_back(param_name_stream__.str());
1289 :         }
1290 : 
1291 :         if (!include_gqs__) return;
1292 :         for (int k_0__ = 1; k_0__ <= T_pred; ++k_0__) {
1293 :             param_name_stream__.str(std::string());
1294 :             param_name_stream__ << "b_tube_pred" << '.' << k_0__;
1295 :             param_names__.push_back(param_name_stream__.str());
1296 :         }
1297 :         for (int k_0__ = 1; k_0__ <= T_pred; ++k_0__) {
1298 :             param_name_stream__.str(std::string());
1299 :             param_name_stream__ << "pred_tot" << '.' << k_0__;
1300 :             param_names__.push_back(param_name_stream__.str());
1301 :         }
1302 :         for (int k_0__ = 1; k_0__ <= N_pred; ++k_0__) {
1303 :             param_name_stream__.str(std::string());
1304 :             param_name_stream__ << "mu_pred" << '.' << k_0__;
1305 :             param_names__.push_back(param_name_stream__.str());
1306 :         }
1307 :         for (int k_0__ = 1; k_0__ <= N_pred; ++k_0__) {
1308 :             param_name_stream__.str(std::string());
1309 :             param_name_stream__ << "mu_obs_pred" << '.' << k_0__;
1310 :             param_names__.push_back(param_name_stream__.str());
1311 :         }
1312 :         for (int k_0__ = 1; k_0__ <= N_pred; ++k_0__) {
1313 :             param_name_stream__.str(std::string());
1314 :             param_name_stream__ << "detect_odds_pred" << '.' << k_0__;
1315 :             param_names__.push_back(param_name_stream__.str());
1316 :         }
1317 :         for (int k_0__ = 1; k_0__ <= N_pred; ++k_0__) {
1318 :             param_name_stream__.str(std::string());
1319 :             param_name_stream__ << "y_pred" << '.' << k_0__;
1320 :             param_names__.push_back(param_name_stream__.str());
1321 :         }
1322 :         for (int k_0__ = 1; k_0__ <= C; ++k_0__) {
1323 :             param_name_stream__.str(std::string());
1324 :             param_name_stream__ << "crop_tot" << '.' << k_0__;
1325 :             param_names__.push_back(param_name_stream__.str());
1326 :         }
1327 :         for (int k_0__ = 1; k_0__ <= (C - 1); ++k_0__) {
1328 :             param_name_stream__.str(std::string());
1329 :             param_name_stream__ << "crop_tot_diff" << '.' << k_0__;
1330 :             param_names__.push_back(param_name_stream__.str());
1331 :         }
1332 :         for (int k_0__ = 1; k_0__ <= (C - 1); ++k_0__) {
1333 :             param_name_stream__.str(std::string());
1334 :             param_name_stream__ << "crop_int_diff" << '.' << k_0__;
1335 :             param_names__.push_back(param_name_stream__.str());
1336 :         }
1337 :         for (int k_0__ = 1; k_0__ <= (C - 1); ++k_0__) {
1338 :             param_name_stream__.str(std::string());
1339 :             param_name_stream__ << "crop_bdepth_diff" << '.' << k_0__;
1340 :             param_names__.push_back(param_name_stream__.str());
1341 :         }
1342 :     }
1343 : 
1344 : }; // model
1345 : 
1346 : } // namespace
1347 : 
1348 : typedef model7e2b110f6d81_mctd_foursurf_namespace::model7e2b110f6d81_mctd_foursurf stan_model;
1349 : 
1350 : #include <rstan/rstaninc.hpp>
1351 : /**
1352 :  * Define Rcpp Module to expose stan_fit's functions to R.
1353 :  */
1354 : RCPP_MODULE(stan_fit4model7e2b110f6d81_mctd_foursurf_mod){
1355 :   Rcpp::class_<rstan::stan_fit<model7e2b110f6d81_mctd_foursurf_namespace::model7e2b110f6d81_mctd_foursurf,
1356 :                boost::random::ecuyer1988> >("stan_fit4model7e2b110f6d81_mctd_foursurf")
1357 :     // .constructor<Rcpp::List>()
1358 :     .constructor<SEXP, SEXP>()
1359 :     // .constructor<SEXP, SEXP>()
1360 :     .method("call_sampler",
1361 :             &rstan::stan_fit<model7e2b110f6d81_mctd_foursurf_namespace::model7e2b110f6d81_mctd_foursurf, boost::random::ecuyer1988>::call_sampler)
1362 :     .method("param_names",
1363 :             &rstan::stan_fit<model7e2b110f6d81_mctd_foursurf_namespace::model7e2b110f6d81_mctd_foursurf, boost::random::ecuyer1988>::param_names)
1364 :     .method("param_names_oi",
1365 :             &rstan::stan_fit<model7e2b110f6d81_mctd_foursurf_namespace::model7e2b110f6d81_mctd_foursurf, boost::random::ecuyer1988>::param_names_oi)
1366 :     .method("param_fnames_oi",
1367 :             &rstan::stan_fit<model7e2b110f6d81_mctd_foursurf_namespace::model7e2b110f6d81_mctd_foursurf, boost::random::ecuyer1988>::param_fnames_oi)
1368 :     .method("param_dims",
1369 :             &rstan::stan_fit<model7e2b110f6d81_mctd_foursurf_namespace::model7e2b110f6d81_mctd_foursurf, boost::random::ecuyer1988>::param_dims)
1370 :     .method("param_dims_oi",
1371 :             &rstan::stan_fit<model7e2b110f6d81_mctd_foursurf_namespace::model7e2b110f6d81_mctd_foursurf, boost::random::ecuyer1988>::param_dims_oi)
1372 :     .method("update_param_oi",
1373 :             &rstan::stan_fit<model7e2b110f6d81_mctd_foursurf_namespace::model7e2b110f6d81_mctd_foursurf, boost::random::ecuyer1988>::update_param_oi)
1374 :     .method("param_oi_tidx",
1375 :             &rstan::stan_fit<model7e2b110f6d81_mctd_foursurf_namespace::model7e2b110f6d81_mctd_foursurf, boost::random::ecuyer1988>::param_oi_tidx)
1376 :     .method("grad_log_prob",
1377 :             &rstan::stan_fit<model7e2b110f6d81_mctd_foursurf_namespace::model7e2b110f6d81_mctd_foursurf, boost::random::ecuyer1988>::grad_log_prob)
1378 :     .method("log_prob",
1379 :             &rstan::stan_fit<model7e2b110f6d81_mctd_foursurf_namespace::model7e2b110f6d81_mctd_foursurf, boost::random::ecuyer1988>::log_prob)
1380 :     .method("unconstrain_pars",
1381 :             &rstan::stan_fit<model7e2b110f6d81_mctd_foursurf_namespace::model7e2b110f6d81_mctd_foursurf, boost::random::ecuyer1988>::unconstrain_pars)
1382 :     .method("constrain_pars",
1383 :             &rstan::stan_fit<model7e2b110f6d81_mctd_foursurf_namespace::model7e2b110f6d81_mctd_foursurf, boost::random::ecuyer1988>::constrain_pars)
1384 :     .method("num_pars_unconstrained",
1385 :             &rstan::stan_fit<model7e2b110f6d81_mctd_foursurf_namespace::model7e2b110f6d81_mctd_foursurf, boost::random::ecuyer1988>::num_pars_unconstrained)
1386 :     .method("unconstrained_param_names",
1387 :             &rstan::stan_fit<model7e2b110f6d81_mctd_foursurf_namespace::model7e2b110f6d81_mctd_foursurf, boost::random::ecuyer1988>::unconstrained_param_names)
1388 :     .method("constrained_param_names",
1389 :             &rstan::stan_fit<model7e2b110f6d81_mctd_foursurf_namespace::model7e2b110f6d81_mctd_foursurf, boost::random::ecuyer1988>::constrained_param_names)
1390 :     ;
1391 : }
1392 : 
1393 : // declarations
1394 : extern "C" {
1395 : SEXP file7e2b2a69cbc7( ) ;
1396 : }
1397 : 
1398 : // definition
1399 : 
1400 : SEXP file7e2b2a69cbc7(  ){
1401 :  return Rcpp::wrap("mctd_foursurf");
1402 : }
1403 : 
1404 : 
Compilation argument:
 /Library/Frameworks/R.framework/Resources/bin/R CMD SHLIB file7e2b2a69cbc7.cpp 2> file7e2b2a69cbc7.cpp.err.txt 
clang++ -ftemplate-depth-256 -I/Library/Frameworks/R.framework/Resources/include -DNDEBUG   -I"/Library/Frameworks/R.framework/Versions/3.3/Resources/library/Rcpp/include/"  -I"/Library/Frameworks/R.framework/Versions/3.3/Resources/library/RcppEigen/include/"  -I"/Library/Frameworks/R.framework/Versions/3.3/Resources/library/RcppEigen/include/unsupported"  -I"/Library/Frameworks/R.framework/Versions/3.3/Resources/library/rstan/include/boost_not_in_BH" -I"/Library/Frameworks/R.framework/Versions/3.3/Resources/library/BH/include" -I"/Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/src/"  -I"/Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/"  -I"/Library/Frameworks/R.framework/Versions/3.3/Resources/library/rstan/include" -DEIGEN_NO_DEBUG  -DBOOST_RESULT_OF_USE_TR1 -DBOOST_NO_DECLTYPE -DBOOST_DISABLE_ASSERTS -I/usr/local/include -I/usr/local/include/freetype2 -I/opt/X11/include    -fPIC  -O3 -Wno-unused-variable -Wno-unused-function -Wno-unused-local-typedefs -march=native -c file7e2b2a69cbc7.cpp -o file7e2b2a69cbc7.o
clang++ -ftemplate-depth-256 -dynamiclib -Wl,-headerpad_max_install_names -undefined dynamic_lookup -single_module -multiply_defined suppress -L/Library/Frameworks/R.framework/Resources/lib -L/usr/local/lib -o file7e2b2a69cbc7.so file7e2b2a69cbc7.o -L/Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/lib -lStanHeaders -F/Library/Frameworks/R.framework/.. -framework R -Wl,-framework -Wl,CoreFoundation

CHECKING DATA AND PREPROCESSING FOR MODEL 'mctd_foursurf' NOW.

COMPILING MODEL 'mctd_foursurf' NOW.

STARTING SAMPLER FOR MODEL 'mctd_foursurf' NOW.
starting worker pid=32380 on localhost:11379 at 09:16:51.829
starting worker pid=32388 on localhost:11379 at 09:16:52.027
starting worker pid=32396 on localhost:11379 at 09:16:52.225
starting worker pid=32404 on localhost:11379 at 09:16:52.420
starting worker pid=32412 on localhost:11379 at 09:16:52.613

CHECKING DATA AND PREPROCESSING FOR MODEL 'mctd_foursurf' NOW.

COMPILING MODEL 'mctd_foursurf' NOW.

STARTING SAMPLER FOR MODEL 'mctd_foursurf' NOW.

SAMPLING FOR MODEL 'mctd_foursurf' NOW (CHAIN 1).

Chain 1, Iteration:    1 / 5000 [  0%]  (Warmup)
CHECKING DATA AND PREPROCESSING FOR MODEL 'mctd_foursurf' NOW.

COMPILING MODEL 'mctd_foursurf' NOW.

STARTING SAMPLER FOR MODEL 'mctd_foursurf' NOW.

SAMPLING FOR MODEL 'mctd_foursurf' NOW (CHAIN 2).

Chain 2, Iteration:    1 / 5000 [  0%]  (Warmup)
CHECKING DATA AND PREPROCESSING FOR MODEL 'mctd_foursurf' NOW.

COMPILING MODEL 'mctd_foursurf' NOW.

STARTING SAMPLER FOR MODEL 'mctd_foursurf' NOW.

SAMPLING FOR MODEL 'mctd_foursurf' NOW (CHAIN 3).

Chain 3, Iteration:    1 / 5000 [  0%]  (Warmup)
CHECKING DATA AND PREPROCESSING FOR MODEL 'mctd_foursurf' NOW.

COMPILING MODEL 'mctd_foursurf' NOW.

STARTING SAMPLER FOR MODEL 'mctd_foursurf' NOW.

SAMPLING FOR MODEL 'mctd_foursurf' NOW (CHAIN 4).

Chain 4, Iteration:    1 / 5000 [  0%]  (Warmup)
CHECKING DATA AND PREPROCESSING FOR MODEL 'mctd_foursurf' NOW.

COMPILING MODEL 'mctd_foursurf' NOW.

STARTING SAMPLER FOR MODEL 'mctd_foursurf' NOW.

SAMPLING FOR MODEL 'mctd_foursurf' NOW (CHAIN 5).

Chain 5, Iteration:    1 / 5000 [  0%]  (Warmup)
Chain 5, Iteration:  500 / 5000 [ 10%]  (Warmup)
Chain 2, Iteration:  500 / 5000 [ 10%]  (Warmup)
Chain 1, Iteration:  500 / 5000 [ 10%]  (Warmup)
Chain 3, Iteration:  500 / 5000 [ 10%]  (Warmup)
Chain 4, Iteration:  500 / 5000 [ 10%]  (Warmup)
Chain 5, Iteration: 1000 / 5000 [ 20%]  (Warmup)
Chain 5, Iteration: 1001 / 5000 [ 20%]  (Sampling)
Chain 1, Iteration: 1000 / 5000 [ 20%]  (Warmup)
Chain 1, Iteration: 1001 / 5000 [ 20%]  (Sampling)
Chain 2, Iteration: 1000 / 5000 [ 20%]  (Warmup)
Chain 2, Iteration: 1001 / 5000 [ 20%]  (Sampling)
Chain 4, Iteration: 1000 / 5000 [ 20%]  (Warmup)
Chain 4, Iteration: 1001 / 5000 [ 20%]  (Sampling)
Chain 3, Iteration: 1000 / 5000 [ 20%]  (Warmup)
Chain 3, Iteration: 1001 / 5000 [ 20%]  (Sampling)
Chain 5, Iteration: 1500 / 5000 [ 30%]  (Sampling)
Chain 1, Iteration: 1500 / 5000 [ 30%]  (Sampling)
Chain 2, Iteration: 1500 / 5000 [ 30%]  (Sampling)
Chain 4, Iteration: 1500 / 5000 [ 30%]  (Sampling)
Chain 3, Iteration: 1500 / 5000 [ 30%]  (Sampling)
Chain 5, Iteration: 2000 / 5000 [ 40%]  (Sampling)
Chain 1, Iteration: 2000 / 5000 [ 40%]  (Sampling)
Chain 2, Iteration: 2000 / 5000 [ 40%]  (Sampling)
Chain 4, Iteration: 2000 / 5000 [ 40%]  (Sampling)
Chain 3, Iteration: 2000 / 5000 [ 40%]  (Sampling)
Chain 5, Iteration: 2500 / 5000 [ 50%]  (Sampling)
Chain 1, Iteration: 2500 / 5000 [ 50%]  (Sampling)
Chain 2, Iteration: 2500 / 5000 [ 50%]  (Sampling)
Chain 4, Iteration: 2500 / 5000 [ 50%]  (Sampling)
Chain 3, Iteration: 2500 / 5000 [ 50%]  (Sampling)
Chain 5, Iteration: 3000 / 5000 [ 60%]  (Sampling)
Chain 1, Iteration: 3000 / 5000 [ 60%]  (Sampling)
Chain 2, Iteration: 3000 / 5000 [ 60%]  (Sampling)
Chain 4, Iteration: 3000 / 5000 [ 60%]  (Sampling)
Chain 3, Iteration: 3000 / 5000 [ 60%]  (Sampling)
Chain 5, Iteration: 3500 / 5000 [ 70%]  (Sampling)
Chain 1, Iteration: 3500 / 5000 [ 70%]  (Sampling)
Chain 4, Iteration: 3500 / 5000 [ 70%]  (Sampling)
Chain 2, Iteration: 3500 / 5000 [ 70%]  (Sampling)
Chain 3, Iteration: 3500 / 5000 [ 70%]  (Sampling)
Chain 5, Iteration: 4000 / 5000 [ 80%]  (Sampling)
Chain 1, Iteration: 4000 / 5000 [ 80%]  (Sampling)
Chain 4, Iteration: 4000 / 5000 [ 80%]  (Sampling)
Chain 2, Iteration: 4000 / 5000 [ 80%]  (Sampling)
Chain 5, Iteration: 4500 / 5000 [ 90%]  (Sampling)
Chain 3, Iteration: 4000 / 5000 [ 80%]  (Sampling)
Chain 1, Iteration: 4500 / 5000 [ 90%]  (Sampling)
Chain 4, Iteration: 4500 / 5000 [ 90%]  (Sampling)
Chain 5, Iteration: 5000 / 5000 [100%]  (Sampling)
 Elapsed Time: 37.2206 seconds (Warm-up)
               138.013 seconds (Sampling)
               175.234 seconds (Total)

The following numerical problems occured the indicated number of times after warmup on chain 5
                                                                                             count
Exception thrown at line 150: lognormal_log: Scale parameter[1] is inf, but must be finite!      4
Exception thrown at line 150: lognormal_log: Scale parameter[12] is inf, but must be finite!     3
When a numerical problem occurs, the Hamiltonian proposal gets rejected.
See http://mc-stan.org/misc/warnings.html#exception-hamiltonian-proposal-rejected
If the number in the 'count' column is small, do not ask about this message on stan-users.

Chain 2, Iteration: 4500 / 5000 [ 90%]  (Sampling)
Chain 3, Iteration: 4500 / 5000 [ 90%]  (Sampling)
Chain 1, Iteration: 5000 / 5000 [100%]  (Sampling)
 Elapsed Time: 44.4437 seconds (Warm-up)
               137.734 seconds (Sampling)
               182.178 seconds (Total)

The following numerical problems occured the indicated number of times after warmup on chain 1
                                                                                            count
Exception thrown at line 150: lognormal_log: Scale parameter[1] is inf, but must be finite!     7
Exception thrown at line 140: normal_log: Scale parameter is 0, but must be > 0!                1
When a numerical problem occurs, the Hamiltonian proposal gets rejected.
See http://mc-stan.org/misc/warnings.html#exception-hamiltonian-proposal-rejected
If the number in the 'count' column is small, do not ask about this message on stan-users.

Chain 4, Iteration: 5000 / 5000 [100%]  (Sampling)
 Elapsed Time: 47.5586 seconds (Warm-up)
               142 seconds (Sampling)
               189.559 seconds (Total)

The following numerical problems occured the indicated number of times after warmup on chain 4
                                                                                            count
Exception thrown at line 150: lognormal_log: Scale parameter[1] is inf, but must be finite!     6
Exception thrown at line 140: normal_log: Scale parameter is 0, but must be > 0!                1
Exception thrown at line 150: lognormal_log: Scale parameter[2] is inf, but must be finite!     1
When a numerical problem occurs, the Hamiltonian proposal gets rejected.
See http://mc-stan.org/misc/warnings.html#exception-hamiltonian-proposal-rejected
If the number in the 'count' column is small, do not ask about this message on stan-users.

Chain 2, Iteration: 5000 / 5000 [100%]  (Sampling)
 Elapsed Time: 44.5037 seconds (Warm-up)
               147.17 seconds (Sampling)
               191.674 seconds (Total)

The following numerical problems occured the indicated number of times after warmup on chain 2
                                                                                            count
Exception thrown at line 150: lognormal_log: Scale parameter[1] is inf, but must be finite!    10
When a numerical problem occurs, the Hamiltonian proposal gets rejected.
See http://mc-stan.org/misc/warnings.html#exception-hamiltonian-proposal-rejected
If the number in the 'count' column is small, do not ask about this message on stan-users.

Chain 3, Iteration: 5000 / 5000 [100%]  (Sampling)
 Elapsed Time: 48.8069 seconds (Warm-up)
               143.047 seconds (Sampling)
               191.854 seconds (Total)

The following numerical problems occured the indicated number of times after warmup on chain 3
                                                                                             count
Exception thrown at line 150: lognormal_log: Scale parameter[1] is inf, but must be finite!      7
Exception thrown at line 150: lognormal_log: Scale parameter[12] is inf, but must be finite!     1
When a numerical problem occurs, the Hamiltonian proposal gets rejected.
See http://mc-stan.org/misc/warnings.html#exception-hamiltonian-proposal-rejected
If the number in the 'count' column is small, do not ask about this message on stan-users.
Warning messages:
1: There were 15 divergent transitions after warmup. Increasing adapt_delta above 0.99 may help. See
http://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup 
2: Examine the pairs() plot to diagnose sampling problems
 
Warning messages:
1: There were 15 divergent transitions after warmup. Increasing adapt_delta above 0.99 may help. See
http://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup
2: Examine the pairs() plot to diagnose sampling problems

Inference for Stan model: mctd_foursurf.
5 chains, each with iter=5000; warmup=1000; thin=1; 
post-warmup draws per chain=4000, total post-warmup draws=20000.

                        mean se_mean    sd     2.5%      25%      50%      75%
loc_detect             -8.00    0.00  0.12    -8.24    -8.08    -8.00    -7.93
scale_detect            0.67    0.00  0.12     0.46     0.59     0.66     0.74
loc_surface[1]         11.97    0.06  6.89    -2.70     7.52    12.50    16.83
loc_surface[2]         15.34    0.03  2.96     9.31    13.45    15.40    17.31
loc_surface[3]         14.62    0.04  4.56     5.76    11.60    14.67    17.63
loc_surface[4]         13.35    0.03  2.89     7.87    11.39    13.27    15.24
scale_surface[1]        7.72    0.03  4.77     1.78     4.76     6.45     9.25
scale_surface[2]        4.70    0.01  1.09     3.08     3.95     4.54     5.27
scale_surface[3]        5.55    0.02  2.09     2.46     4.24     5.23     6.50
scale_surface[4]        3.62    0.01  0.89     2.07     3.02     3.55     4.15
intercept[1]           -9.61    0.01  0.39   -10.42    -9.86    -9.59    -9.34
intercept[2]           -7.52    0.00  0.17    -7.84    -7.63    -7.52    -7.41
intercept[3]           -8.46    0.00  0.22    -8.93    -8.60    -8.45    -8.31
intercept[4]           -7.87    0.00  0.16    -8.18    -7.97    -7.87    -7.77
b_depth[1]             -1.04    0.00  0.35    -1.85    -1.24    -0.99    -0.79
b_depth[2]             -0.86    0.00  0.20    -1.27    -0.99    -0.85    -0.72
b_depth[3]             -0.97    0.00  0.26    -1.54    -1.13    -0.95    -0.78
b_depth[4]             -0.98    0.00  0.21    -1.42    -1.11    -0.97    -0.83
sig_tube                0.48    0.00  0.10     0.32     0.42     0.48     0.54
sigma[1]                2.48    0.00  0.35     1.90     2.23     2.44     2.69
sigma[2]                2.46    0.00  0.12     2.23     2.38     2.45     2.54
sigma[3]                2.37    0.00  0.17     2.06     2.25     2.36     2.48
sigma[4]                2.32    0.00  0.11     2.12     2.25     2.32     2.39
crop_tot[1]             0.03    0.00  0.04     0.01     0.01     0.02     0.03
crop_tot[2]             0.13    0.00  0.05     0.07     0.10     0.12     0.15
crop_tot[3]             0.06    0.00  0.04     0.03     0.04     0.05     0.07
crop_tot[4]             0.11    0.00  0.05     0.06     0.08     0.10     0.12
crop_tot_diff[1]        0.10    0.00  0.07     0.02     0.07     0.09     0.12
crop_tot_diff[2]        0.04    0.00  0.06    -0.04     0.02     0.03     0.05
crop_tot_diff[3]        0.08    0.00  0.07     0.00     0.05     0.07     0.10
crop_int_diff[1]        2.09    0.01  0.43     1.33     1.79     2.06     2.36
crop_int_diff[2]        1.15    0.00  0.34     0.55     0.91     1.13     1.36
crop_int_diff[3]        1.74    0.01  0.38     1.06     1.47     1.72     1.98
crop_bdepth_diff[1]     0.18    0.00  0.37    -0.47    -0.08     0.15     0.41
crop_bdepth_diff[2]     0.07    0.00  0.40    -0.65    -0.20     0.04     0.32
crop_bdepth_diff[3]     0.06    0.00  0.36    -0.57    -0.19     0.03     0.28
lp__                -1502.11    0.36 14.01 -1529.30 -1511.53 -1502.18 -1492.55
                       97.5% n_eff Rhat
loc_detect             -7.78  5497    1
scale_detect            0.91  1916    1
loc_surface[1]         24.02 12223    1
loc_surface[2]         21.05 10142    1
loc_surface[3]         23.43 12083    1
loc_surface[4]         19.22  7601    1
scale_surface[1]       20.63 20000    1
scale_surface[2]        7.27 11617    1
scale_surface[3]       10.43 12657    1
scale_surface[4]        5.56 12429    1
intercept[1]           -8.91  2530    1
intercept[2]           -7.18  8094    1
intercept[3]           -8.06  3477    1
intercept[4]           -7.57  6786    1
b_depth[1]             -0.51  5421    1
b_depth[2]             -0.49  7486    1
b_depth[3]             -0.52  6873    1
b_depth[4]             -0.62  3713    1
sig_tube                0.69  1903    1
sigma[1]                3.27 20000    1
sigma[2]                2.71 20000    1
sigma[3]                2.73 20000    1
sigma[4]                2.55 20000    1
crop_tot[1]             0.10 12432    1
crop_tot[2]             0.27  6742    1
crop_tot[3]             0.16 10951    1
crop_tot[4]             0.24  5664    1
crop_tot_diff[1]        0.24  9880    1
crop_tot_diff[2]        0.14 11676    1
crop_tot_diff[3]        0.22  9455    1
crop_int_diff[1]        3.00  2466    1
crop_int_diff[2]        1.86  4837    1
crop_int_diff[3]        2.56  2867    1
crop_bdepth_diff[1]     1.02 10242    1
crop_bdepth_diff[2]     0.93 10711    1
crop_bdepth_diff[3]     0.85 12040    1
lp__                -1474.90  1542    1

Samples were drawn using NUTS(diag_e) at Sat Nov 19 09:20:11 2016.
For each parameter, n_eff is a crude measure of effective sample size,
and Rhat is the potential scale reduction factor on split chains (at 
convergence, Rhat=1).
Inference for Stan model: mctd_foursurf.
5 chains, each with iter=5000; warmup=1000; thin=1; 
post-warmup draws per chain=4000, total post-warmup draws=20000.

                      mean se_mean   sd   2.5%   25%   50%   75% 97.5% n_eff
y_pred[1]             0.02    0.00 0.25   0.00  0.00  0.00  0.00  0.07 20000
y_pred[15]            0.01    0.00 0.17   0.00  0.00  0.00  0.00  0.07 20000
y_pred[28]            0.00    0.00 0.06   0.00  0.00  0.00  0.00  0.00 20000
mu_pred[1]           -4.10    0.01 0.97  -5.91 -4.77 -4.14 -3.48 -2.09  8096
mu_pred[15]          -6.94    0.00 0.56  -8.02 -7.31 -6.95 -6.59 -5.79 15535
mu_pred[28]          -9.35    0.01 0.61 -10.63 -9.75 -9.31 -8.93 -8.21  7184
mu_obs_pred[1]       -7.33    0.00 0.64  -8.60 -7.75 -7.32 -6.91 -6.08 18555
mu_obs_pred[15]      -7.09    0.00 0.54  -8.15 -7.45 -7.10 -6.75 -5.99 17001
mu_obs_pred[28]      -9.39    0.01 0.61 -10.67 -9.78 -9.36 -8.97 -8.25  7117
detect_odds_pred[1]   0.71    0.00 0.17   0.30  0.60  0.74  0.84  0.95 17827
detect_odds_pred[15]  0.77    0.00 0.13   0.45  0.70  0.80  0.87  0.95 19005
detect_odds_pred[28]  0.14    0.00 0.10   0.02  0.07  0.11  0.18  0.39 19182
pred_tot[1]           0.15    0.00 0.11   0.04  0.08  0.12  0.17  0.42 10211
                     Rhat
y_pred[1]               1
y_pred[15]              1
y_pred[28]              1
mu_pred[1]              1
mu_pred[15]             1
mu_pred[28]             1
mu_obs_pred[1]          1
mu_obs_pred[15]         1
mu_obs_pred[28]         1
detect_odds_pred[1]     1
detect_odds_pred[15]    1
detect_odds_pred[28]    1
pred_tot[1]             1

Samples were drawn using NUTS(diag_e) at Sat Nov 19 09:20:11 2016.
For each parameter, n_eff is a crude measure of effective sample size,
and Rhat is the potential scale reduction factor on split chains (at 
convergence, Rhat=1).
[1] "mean of depth: 53.7776934749621"

mean of log(nonzero root volume): -7.669138 

RMSE of mu_obs vs log observed (zeroes excluded):  2.353614 
RMSE/var:  0.3881231 

ci_level: 0.8 (80% intervals)
outer_level: 0.95 (95% intervals)
ci_level: 0.8 (80% intervals)
outer_level: 0.95 (95% intervals)
ci_level: 0.8 (80% intervals)
outer_level: 0.95 (95% intervals)
ci_level: 0.8 (80% intervals)
outer_level: 0.95 (95% intervals)
ci_level: 0.8 (80% intervals)
outer_level: 0.95 (95% intervals)
ci_level: 0.8 (80% intervals)
outer_level: 0.95 (95% intervals)
ci_level: 0.8 (80% intervals)
outer_level: 0.95 (95% intervals)
Warning message:
Removed 719 rows containing non-finite values (stat_smooth). 
null device 
          1 

real	5m2.065s
user	1m35.815s
sys	0m5.503s
Extracting fits
Loading required package: ggplot2
Loading required package: StanHeaders
rstan (Version 2.12.1, packaged: , GitRev: 85f7a56811da)
For execution on a local, multicore CPU with excess RAM we recommend calling
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())

Attaching package: dplyr

The following objects are masked from package:stats:

    filter, lag

The following objects are masked from package:base:

    intersect, setdiff, setequal, union

Joining, by = c("term", "estimate", "std.error", "rhat", "ess")
Joining, by = "crop_num"
Joining, by = "parameter"
